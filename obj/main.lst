                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ISO C Compiler
                                      3 ; Version 4.5.0 #15242 (MINGW64)
                                      4 ;--------------------------------------------------------
                                      5 	.module main
                                      6 	
                                      7 ;--------------------------------------------------------
                                      8 ; Public variables in this module
                                      9 ;--------------------------------------------------------
                                     10 	.globl _main
                                     11 	.globl _WWDG_GetCounter
                                     12 	.globl _WWDG_SetCounter
                                     13 	.globl _WWDG_Init
                                     14 	.globl _TIM4_ClearFlag
                                     15 	.globl _TIM4_GetFlagStatus
                                     16 	.globl _TIM4_SetCounter
                                     17 	.globl _TIM4_Cmd
                                     18 	.globl _TIM4_TimeBaseInit
                                     19 	.globl _GPIO_ReadInputPin
                                     20 	.globl _GPIO_WriteLow
                                     21 	.globl _GPIO_WriteHigh
                                     22 	.globl _GPIO_Init
                                     23 	.globl _GPIO_DeInit
                                     24 	.globl _CLK_HSIPrescalerConfig
                                     25 	.globl _CLK_PeripheralClockConfig
                                     26 ;--------------------------------------------------------
                                     27 ; ram data
                                     28 ;--------------------------------------------------------
                                     29 	.area DATA
                                     30 ;--------------------------------------------------------
                                     31 ; ram data
                                     32 ;--------------------------------------------------------
                                     33 	.area INITIALIZED
      000000                         34 _uptime_ms:
      000000                         35 	.ds 4
      000004                         36 _uptime_s:
      000004                         37 	.ds 4
      000008                         38 _btn:
      000008                         39 	.ds 11
      000013                         40 _mode:
      000013                         41 	.ds 1
      000014                         42 _fan_on:
      000014                         43 	.ds 1
      000015                         44 _fan_on_started_s:
      000015                         45 	.ds 4
      000019                         46 _next_on_time_s:
      000019                         47 	.ds 4
      00001D                         48 _lfsr:
      00001D                         49 	.ds 2
                                     50 ;--------------------------------------------------------
                                     51 ; Stack segment in internal ram
                                     52 ;--------------------------------------------------------
                                     53 	.area SSEG
      000000                         54 __start__stack:
      000000                         55 	.ds	1
                                     56 
                                     57 ;--------------------------------------------------------
                                     58 ; absolute external ram data
                                     59 ;--------------------------------------------------------
                                     60 	.area DABS (ABS)
                                     61 
                                     62 ; default segment ordering for linker
                                     63 	.area HOME
                                     64 	.area GSINIT
                                     65 	.area GSFINAL
                                     66 	.area CONST
                                     67 	.area INITIALIZER
                                     68 	.area CODE
                                     69 
                                     70 ;--------------------------------------------------------
                                     71 ; interrupt vector
                                     72 ;--------------------------------------------------------
                                     73 	.area HOME
      000000                         74 __interrupt_vect:
      000000 82v00u00u00             75 	int s_GSINIT ; reset
                                     76 ;--------------------------------------------------------
                                     77 ; global & static initialisations
                                     78 ;--------------------------------------------------------
                                     79 	.area HOME
                                     80 	.area GSINIT
                                     81 	.area GSFINAL
                                     82 	.area GSINIT
      000000 CDr00r00         [ 4]   83 	call	___sdcc_external_startup
      000003 4D               [ 1]   84 	tnz	a
      000004 27 03            [ 1]   85 	jreq	__sdcc_init_data
      000006 CCr00r04         [ 2]   86 	jp	__sdcc_program_startup
      000009                         87 __sdcc_init_data:
                                     88 ; stm8_genXINIT() start
      000009 AEr00r00         [ 2]   89 	ldw x, #l_DATA
      00000C 27 07            [ 1]   90 	jreq	00002$
      00000E                         91 00001$:
      00000E 72 4FuFFuFF      [ 1]   92 	clr (s_DATA - 1, x)
      000012 5A               [ 2]   93 	decw x
      000013 26 F9            [ 1]   94 	jrne	00001$
      000015                         95 00002$:
      000015 AEr00r00         [ 2]   96 	ldw	x, #l_INITIALIZER
      000018 27 09            [ 1]   97 	jreq	00004$
      00001A                         98 00003$:
      00001A D6uFFuFF         [ 1]   99 	ld	a, (s_INITIALIZER - 1, x)
      00001D D7uFFuFF         [ 1]  100 	ld	(s_INITIALIZED - 1, x), a
      000020 5A               [ 2]  101 	decw	x
      000021 26 F7            [ 1]  102 	jrne	00003$
      000023                        103 00004$:
                                    104 ; stm8_genXINIT() end
                                    105 	.area GSFINAL
      000000 CCr00r04         [ 2]  106 	jp	__sdcc_program_startup
                                    107 ;--------------------------------------------------------
                                    108 ; Home
                                    109 ;--------------------------------------------------------
                                    110 	.area HOME
                                    111 	.area HOME
      000004                        112 __sdcc_program_startup:
      000004 CCr03r7E         [ 2]  113 	jp	_main
                                    114 ;	return from main will return to caller
                                    115 ;--------------------------------------------------------
                                    116 ; code
                                    117 ;--------------------------------------------------------
                                    118 	.area CODE
                                    119 ;	main.c: 69: static inline void tick_1ms_poll(void) {
                                    120 ;	-----------------------------------------
                                    121 ;	 function tick_1ms_poll
                                    122 ;	-----------------------------------------
      000000                        123 _tick_1ms_poll:
                                    124 ;	main.c: 70: if (TIM4_GetFlagStatus(TIM4_FLAG_UPDATE) != RESET) {
      000000 A6 01            [ 1]  125 	ld	a, #0x01
      000002 CDr00r00         [ 4]  126 	call	_TIM4_GetFlagStatus
      000005 4D               [ 1]  127 	tnz	a
      000006 26 01            [ 1]  128 	jrne	00121$
      000008 81               [ 4]  129 	ret
      000009                        130 00121$:
                                    131 ;	main.c: 71: TIM4_ClearFlag(TIM4_FLAG_UPDATE);
      000009 A6 01            [ 1]  132 	ld	a, #0x01
      00000B CDr00r00         [ 4]  133 	call	_TIM4_ClearFlag
                                    134 ;	main.c: 72: uptime_ms++;
      00000E CEu00u02         [ 2]  135 	ldw	x, _uptime_ms+2
      000011 90 CEu00u00      [ 2]  136 	ldw	y, _uptime_ms+0
      000015 5C               [ 1]  137 	incw	x
      000016 26 02            [ 1]  138 	jrne	00122$
      000018 90 5C            [ 1]  139 	incw	y
      00001A                        140 00122$:
      00001A CFu00u02         [ 2]  141 	ldw	_uptime_ms+2, x
      00001D 90 CFu00u00      [ 2]  142 	ldw	_uptime_ms+0, y
                                    143 ;	main.c: 73: if ((uptime_ms % MS_PER_SEC) == 0u) {
      000021 4B E8            [ 1]  144 	push	#0xe8
      000023 4B 03            [ 1]  145 	push	#0x03
      000025 5F               [ 1]  146 	clrw	x
      000026 89               [ 2]  147 	pushw	x
      000027 3Bu00u03         [ 1]  148 	push	_uptime_ms+3
      00002A 3Bu00u02         [ 1]  149 	push	_uptime_ms+2
      00002D 3Bu00u01         [ 1]  150 	push	_uptime_ms+1
      000030 3Bu00u00         [ 1]  151 	push	_uptime_ms+0
      000033 CDr00r00         [ 4]  152 	call	__modulong
      000036 5B 08            [ 2]  153 	addw	sp, #8
      000038 5D               [ 2]  154 	tnzw	x
      000039 26 04            [ 1]  155 	jrne	00123$
      00003B 90 5D            [ 2]  156 	tnzw	y
      00003D 27 01            [ 1]  157 	jreq	00124$
      00003F                        158 00123$:
      00003F 81               [ 4]  159 	ret
      000040                        160 00124$:
                                    161 ;	main.c: 74: uptime_s++;
      000040 CEu00u06         [ 2]  162 	ldw	x, _uptime_s+2
      000043 90 CEu00u04      [ 2]  163 	ldw	y, _uptime_s+0
      000047 5C               [ 1]  164 	incw	x
      000048 26 02            [ 1]  165 	jrne	00125$
      00004A 90 5C            [ 1]  166 	incw	y
      00004C                        167 00125$:
      00004C CFu00u06         [ 2]  168 	ldw	_uptime_s+2, x
      00004F 90 CFu00u04      [ 2]  169 	ldw	_uptime_s+0, y
                                    170 ;	main.c: 77: }
      000053 81               [ 4]  171 	ret
                                    172 ;	main.c: 80: static inline uint16_t rand16(void) {
                                    173 ;	-----------------------------------------
                                    174 ;	 function rand16
                                    175 ;	-----------------------------------------
      000054                        176 _rand16:
      000054 52 04            [ 2]  177 	sub	sp, #4
                                    178 ;	main.c: 82: uint16_t lsb = (uint16_t)((lfsr ^ (lfsr >> 2) ^ (lfsr >> 3) ^ (lfsr >> 5)) & 1u);
      000056 CEu00u1D         [ 2]  179 	ldw	x, _lfsr+0
      000059 54               [ 2]  180 	srlw	x
      00005A 54               [ 2]  181 	srlw	x
      00005B 9F               [ 1]  182 	ld	a, xl
      00005C C8u00u1E         [ 1]  183 	xor	a, _lfsr+1
      00005F 6B 02            [ 1]  184 	ld	(0x02, sp), a
      000061 9E               [ 1]  185 	ld	a, xh
      000062 C8u00u1D         [ 1]  186 	xor	a, _lfsr+0
      000065 6B 01            [ 1]  187 	ld	(0x01, sp), a
      000067 CEu00u1D         [ 2]  188 	ldw	x, _lfsr+0
      00006A 54               [ 2]  189 	srlw	x
      00006B 54               [ 2]  190 	srlw	x
      00006C 54               [ 2]  191 	srlw	x
      00006D 9F               [ 1]  192 	ld	a, xl
      00006E 18 02            [ 1]  193 	xor	a, (0x02, sp)
      000070 6B 04            [ 1]  194 	ld	(0x04, sp), a
      000072 9E               [ 1]  195 	ld	a, xh
      000073 18 01            [ 1]  196 	xor	a, (0x01, sp)
      000075 6B 03            [ 1]  197 	ld	(0x03, sp), a
      000077 CEu00u1D         [ 2]  198 	ldw	x, _lfsr+0
      00007A A6 20            [ 1]  199 	ld	a, #0x20
      00007C 62               [ 2]  200 	div	x, a
      00007D 9F               [ 1]  201 	ld	a, xl
      00007E 18 04            [ 1]  202 	xor	a, (0x04, sp)
      000080 97               [ 1]  203 	ld	xl, a
      000081 9E               [ 1]  204 	ld	a, xh
      000082 18 03            [ 1]  205 	xor	a, (0x03, sp)
      000084 9F               [ 1]  206 	ld	a, xl
      000085 A4 01            [ 1]  207 	and	a, #0x01
      000087 97               [ 1]  208 	ld	xl, a
                                    209 ;	main.c: 83: lfsr = (uint16_t)((lfsr >> 1) | (lsb << 15));
      000088 90 CEu00u1D      [ 2]  210 	ldw	y, _lfsr+0
      00008C 90 54            [ 2]  211 	srlw	y
      00008E 9F               [ 1]  212 	ld	a, xl
      00008F 5F               [ 1]  213 	clrw	x
      000090 44               [ 1]  214 	srl	a
      000091 56               [ 2]  215 	rrcw	x
      000092 1F 03            [ 2]  216 	ldw	(0x03, sp), x
      000094 90 9E            [ 1]  217 	ld	a, yh
      000096 1A 03            [ 1]  218 	or	a, (0x03, sp)
      000098 90 95            [ 1]  219 	ld	yh, a
      00009A 90 CFu00u1D      [ 2]  220 	ldw	_lfsr+0, y
                                    221 ;	main.c: 84: return lfsr;
      00009E CEu00u1D         [ 2]  222 	ldw	x, _lfsr+0
                                    223 ;	main.c: 85: }
      0000A1 5B 04            [ 2]  224 	addw	sp, #4
      0000A3 81               [ 4]  225 	ret
                                    226 ;	main.c: 88: static uint32_t rand_minutes_range_to_seconds(uint8_t min_min, uint8_t max_min) {
                                    227 ;	-----------------------------------------
                                    228 ;	 function rand_minutes_range_to_seconds
                                    229 ;	-----------------------------------------
      0000A4                        230 _rand_minutes_range_to_seconds:
      0000A4 52 06            [ 2]  231 	sub	sp, #6
      0000A6 6B 06            [ 1]  232 	ld	(0x06, sp), a
                                    233 ;	main.c: 89: uint8_t span = (uint8_t)(max_min - min_min + 1u);
      0000A8 7B 09            [ 1]  234 	ld	a, (0x09, sp)
      0000AA 10 06            [ 1]  235 	sub	a, (0x06, sp)
      0000AC 4C               [ 1]  236 	inc	a
      0000AD 6B 01            [ 1]  237 	ld	(0x01, sp), a
                                    238 ;	main.c: 82: uint16_t lsb = (uint16_t)((lfsr ^ (lfsr >> 2) ^ (lfsr >> 3) ^ (lfsr >> 5)) & 1u);
      0000AF CEu00u1D         [ 2]  239 	ldw	x, _lfsr+0
      0000B2 54               [ 2]  240 	srlw	x
      0000B3 54               [ 2]  241 	srlw	x
      0000B4 9F               [ 1]  242 	ld	a, xl
      0000B5 C8u00u1E         [ 1]  243 	xor	a, _lfsr+1
      0000B8 6B 03            [ 1]  244 	ld	(0x03, sp), a
      0000BA 9E               [ 1]  245 	ld	a, xh
      0000BB C8u00u1D         [ 1]  246 	xor	a, _lfsr+0
      0000BE 6B 02            [ 1]  247 	ld	(0x02, sp), a
      0000C0 CEu00u1D         [ 2]  248 	ldw	x, _lfsr+0
      0000C3 54               [ 2]  249 	srlw	x
      0000C4 54               [ 2]  250 	srlw	x
      0000C5 54               [ 2]  251 	srlw	x
      0000C6 9F               [ 1]  252 	ld	a, xl
      0000C7 18 03            [ 1]  253 	xor	a, (0x03, sp)
      0000C9 6B 05            [ 1]  254 	ld	(0x05, sp), a
      0000CB 9E               [ 1]  255 	ld	a, xh
      0000CC 18 02            [ 1]  256 	xor	a, (0x02, sp)
      0000CE 6B 04            [ 1]  257 	ld	(0x04, sp), a
      0000D0 CEu00u1D         [ 2]  258 	ldw	x, _lfsr+0
      0000D3 A6 20            [ 1]  259 	ld	a, #0x20
      0000D5 62               [ 2]  260 	div	x, a
      0000D6 9F               [ 1]  261 	ld	a, xl
      0000D7 18 05            [ 1]  262 	xor	a, (0x05, sp)
      0000D9 97               [ 1]  263 	ld	xl, a
      0000DA 9E               [ 1]  264 	ld	a, xh
      0000DB 18 04            [ 1]  265 	xor	a, (0x04, sp)
      0000DD 9F               [ 1]  266 	ld	a, xl
      0000DE A4 01            [ 1]  267 	and	a, #0x01
      0000E0 97               [ 1]  268 	ld	xl, a
                                    269 ;	main.c: 90: uint8_t r = (uint8_t)(rand16() % span);
      0000E1 90 CEu00u1D      [ 2]  270 	ldw	y, _lfsr+0
      0000E5 90 54            [ 2]  271 	srlw	y
      0000E7 9F               [ 1]  272 	ld	a, xl
      0000E8 5F               [ 1]  273 	clrw	x
      0000E9 44               [ 1]  274 	srl	a
      0000EA 56               [ 2]  275 	rrcw	x
      0000EB 1F 04            [ 2]  276 	ldw	(0x04, sp), x
      0000ED 90 9E            [ 1]  277 	ld	a, yh
      0000EF 1A 04            [ 1]  278 	or	a, (0x04, sp)
      0000F1 90 95            [ 1]  279 	ld	yh, a
      0000F3 90 CFu00u1D      [ 2]  280 	ldw	_lfsr+0, y
      0000F7 CEu00u1D         [ 2]  281 	ldw	x, _lfsr+0
      0000FA 7B 01            [ 1]  282 	ld	a, (0x01, sp)
      0000FC 90 5F            [ 1]  283 	clrw	y
      0000FE 90 97            [ 1]  284 	ld	yl, a
      000100 65               [ 2]  285 	divw	x, y
      000101 93               [ 1]  286 	ldw	x, y
                                    287 ;	main.c: 91: uint8_t minutes = (uint8_t)(min_min + r);
      000102 72 FB 05         [ 2]  288 	addw	x, (5, sp)
                                    289 ;	main.c: 92: return (uint32_t)minutes * 60u;
      000105 A6 3C            [ 1]  290 	ld	a, #0x3c
      000107 42               [ 4]  291 	mul	x, a
      000108 90 5F            [ 1]  292 	clrw	y
                                    293 ;	main.c: 93: }
      00010A 5B 06            [ 2]  294 	addw	sp, #6
      00010C 81               [ 4]  295 	ret
                                    296 ;	main.c: 96: static inline void fan_off(void)  { GPIO_WriteLow (FAN_PORT, FAN_PIN);  fan_on = 0; }
                                    297 ;	-----------------------------------------
                                    298 ;	 function fan_off
                                    299 ;	-----------------------------------------
      00010D                        300 _fan_off:
      00010D A6 10            [ 1]  301 	ld	a, #0x10
      00010F AE 50 0F         [ 2]  302 	ldw	x, #0x500f
      000112 CDr00r00         [ 4]  303 	call	_GPIO_WriteLow
      000115 72 5Fu00u14      [ 1]  304 	clr	_fan_on+0
      000119 81               [ 4]  305 	ret
                                    306 ;	main.c: 97: static inline void fan_on_fn(void){ GPIO_WriteHigh(FAN_PORT, FAN_PIN);  fan_on = 1; fan_on_started_s = uptime_s; }
                                    307 ;	-----------------------------------------
                                    308 ;	 function fan_on_fn
                                    309 ;	-----------------------------------------
      00011A                        310 _fan_on_fn:
      00011A A6 10            [ 1]  311 	ld	a, #0x10
      00011C AE 50 0F         [ 2]  312 	ldw	x, #0x500f
      00011F CDr00r00         [ 4]  313 	call	_GPIO_WriteHigh
      000122 35 01u00u14      [ 1]  314 	mov	_fan_on+0, #0x01
      000126 CEu00u06         [ 2]  315 	ldw	x, _uptime_s+2
      000129 90 CEu00u04      [ 2]  316 	ldw	y, _uptime_s+0
      00012D CFu00u17         [ 2]  317 	ldw	_fan_on_started_s+2, x
      000130 90 CFu00u15      [ 2]  318 	ldw	_fan_on_started_s+0, y
      000134 81               [ 4]  319 	ret
                                    320 ;	main.c: 100: static void led_off_all(void) {
                                    321 ;	-----------------------------------------
                                    322 ;	 function led_off_all
                                    323 ;	-----------------------------------------
      000135                        324 _led_off_all:
                                    325 ;	main.c: 101: GPIO_WriteHigh(LED_R_PORT, LED_R_PIN);
      000135 A6 80            [ 1]  326 	ld	a, #0x80
      000137 AE 50 0A         [ 2]  327 	ldw	x, #0x500a
      00013A CDr00r00         [ 4]  328 	call	_GPIO_WriteHigh
                                    329 ;	main.c: 102: GPIO_WriteHigh(LED_G_PORT, LED_G_PIN);
      00013D A6 40            [ 1]  330 	ld	a, #0x40
      00013F AE 50 0A         [ 2]  331 	ldw	x, #0x500a
      000142 CDr00r00         [ 4]  332 	call	_GPIO_WriteHigh
                                    333 ;	main.c: 103: GPIO_WriteHigh(LED_B_PORT, LED_B_PIN);
      000145 A6 20            [ 1]  334 	ld	a, #0x20
      000147 AE 50 0A         [ 2]  335 	ldw	x, #0x500a
                                    336 ;	main.c: 104: }
      00014A CCr00r00         [ 2]  337 	jp	_GPIO_WriteHigh
                                    338 ;	main.c: 106: static void led_set_for_mode(mode_t m) {
                                    339 ;	-----------------------------------------
                                    340 ;	 function led_set_for_mode
                                    341 ;	-----------------------------------------
      00014D                        342 _led_set_for_mode:
                                    343 ;	main.c: 107: led_off_all();
      00014D 88               [ 1]  344 	push	a
      00014E CDr01r35         [ 4]  345 	call	_led_off_all
      000151 84               [ 1]  346 	pop	a
                                    347 ;	main.c: 108: switch (m) {
      000152 A1 01            [ 1]  348 	cp	a, #0x01
      000154 27 09            [ 1]  349 	jreq	00101$
      000156 A1 02            [ 1]  350 	cp	a, #0x02
      000158 27 0D            [ 1]  351 	jreq	00102$
      00015A A1 03            [ 1]  352 	cp	a, #0x03
      00015C 27 11            [ 1]  353 	jreq	00103$
      00015E 81               [ 4]  354 	ret
                                    355 ;	main.c: 109: case MODE_ECO:  GPIO_WriteLow(LED_G_PORT, LED_G_PIN); break; /* Green  */
      00015F                        356 00101$:
      00015F A6 40            [ 1]  357 	ld	a, #0x40
      000161 AE 50 0A         [ 2]  358 	ldw	x, #0x500a
      000164 CCr00r00         [ 2]  359 	jp	_GPIO_WriteLow
                                    360 ;	main.c: 110: case MODE_MID:  GPIO_WriteLow(LED_B_PORT, LED_B_PIN); break; /* Blue   */
      000167                        361 00102$:
      000167 A6 20            [ 1]  362 	ld	a, #0x20
      000169 AE 50 0A         [ 2]  363 	ldw	x, #0x500a
      00016C CCr00r00         [ 2]  364 	jp	_GPIO_WriteLow
                                    365 ;	main.c: 111: case MODE_HIGH: GPIO_WriteLow(LED_R_PORT, LED_R_PIN); break; /* Red    */
      00016F                        366 00103$:
      00016F A6 80            [ 1]  367 	ld	a, #0x80
      000171 AE 50 0A         [ 2]  368 	ldw	x, #0x500a
                                    369 ;	main.c: 113: }
                                    370 ;	main.c: 114: }
      000174 CCr00r00         [ 2]  371 	jp	_GPIO_WriteLow
                                    372 ;	main.c: 117: static inline uint8_t button_raw_level(void) {
                                    373 ;	-----------------------------------------
                                    374 ;	 function button_raw_level
                                    375 ;	-----------------------------------------
      000177                        376 _button_raw_level:
                                    377 ;	main.c: 118: return (uint8_t)GPIO_ReadInputPin(BTN_PORT, BTN_PIN) ? 1u : 0u;
      000177 A6 10            [ 1]  378 	ld	a, #0x10
      000179 AE 50 05         [ 2]  379 	ldw	x, #0x5005
      00017C CDr00r00         [ 4]  380 	call	_GPIO_ReadInputPin
      00017F 4D               [ 1]  381 	tnz	a
      000180 27 03            [ 1]  382 	jreq	00103$
      000182 A6 01            [ 1]  383 	ld	a, #0x01
      000184 81               [ 4]  384 	ret
      000185                        385 00103$:
      000185 4F               [ 1]  386 	clr	a
                                    387 ;	main.c: 119: }
      000186 81               [ 4]  388 	ret
                                    389 ;	main.c: 122: static void button_update_1ms(void) {
                                    390 ;	-----------------------------------------
                                    391 ;	 function button_update_1ms
                                    392 ;	-----------------------------------------
      000187                        393 _button_update_1ms:
      000187 52 04            [ 2]  394 	sub	sp, #4
                                    395 ;	main.c: 123: uint8_t raw = button_raw_level();
      000189 A6 10            [ 1]  396 	ld	a, #0x10
      00018B AE 50 05         [ 2]  397 	ldw	x, #0x5005
      00018E CDr00r00         [ 4]  398 	call	_GPIO_ReadInputPin
      000191 4D               [ 1]  399 	tnz	a
      000192 27 03            [ 1]  400 	jreq	00123$
      000194 A6 01            [ 1]  401 	ld	a, #0x01
      000196 21                     402 	.byte 0x21
      000197                        403 00123$:
      000197 4F               [ 1]  404 	clr	a
      000198                        405 00124$:
      000198 6B 03            [ 1]  406 	ld	(0x03, sp), a
      00019A 6B 04            [ 1]  407 	ld	(0x04, sp), a
                                    408 ;	main.c: 125: if (raw == btn.last_sample) {
      00019C C6u00u09         [ 1]  409 	ld	a, _btn+1
                                    410 ;	main.c: 126: if (btn.stable_time_ms < 0xFFFF) btn.stable_time_ms++;
                                    411 ;	main.c: 125: if (raw == btn.last_sample) {
      00019F 11 03            [ 1]  412 	cp	a, (0x03, sp)
      0001A1 26 11            [ 1]  413 	jrne	00104$
                                    414 ;	main.c: 126: if (btn.stable_time_ms < 0xFFFF) btn.stable_time_ms++;
      0001A3 CEu00u0A         [ 2]  415 	ldw	x, _btn+2
      0001A6 90 93            [ 1]  416 	ldw	y, x
      0001A8 90 A3 FF FF      [ 2]  417 	cpw	y, #0xffff
      0001AC 24 12            [ 1]  418 	jrnc	00105$
      0001AE 5C               [ 1]  419 	incw	x
      0001AF CFu00u0A         [ 2]  420 	ldw	_btn+2, x
      0001B2 20 0C            [ 2]  421 	jra	00105$
      0001B4                        422 00104$:
                                    423 ;	main.c: 128: btn.stable_time_ms = 0;
      0001B4 AEr00r0A         [ 2]  424 	ldw	x, #(_btn+2)
      0001B7 6F 01            [ 1]  425 	clr	(0x1, x)
      0001B9 7F               [ 1]  426 	clr	(x)
                                    427 ;	main.c: 129: btn.last_sample = raw;
      0001BA AEr00r09         [ 2]  428 	ldw	x, #(_btn+1)
      0001BD 7B 03            [ 1]  429 	ld	a, (0x03, sp)
      0001BF F7               [ 1]  430 	ld	(x), a
      0001C0                        431 00105$:
                                    432 ;	main.c: 132: if (btn.stable_time_ms == DEBOUNCE_MS) {
      0001C0 CEu00u0A         [ 2]  433 	ldw	x, _btn+2
      0001C3 A3 00 14         [ 2]  434 	cpw	x, #0x0014
      0001C6 26 6B            [ 1]  435 	jrne	00121$
                                    436 ;	main.c: 133: if (raw != btn.stable_level) {
      0001C8 AEr00r08         [ 2]  437 	ldw	x, #(_btn+0)
      0001CB F6               [ 1]  438 	ld	a, (x)
      0001CC 11 04            [ 1]  439 	cp	a, (0x04, sp)
      0001CE 27 63            [ 1]  440 	jreq	00121$
                                    441 ;	main.c: 134: btn.stable_level = raw;
      0001D0 7B 04            [ 1]  442 	ld	a, (0x04, sp)
      0001D2 F7               [ 1]  443 	ld	(x), a
                                    444 ;	main.c: 137: btn.in_press = 1u;
                                    445 ;	main.c: 138: btn.press_start_ms = uptime_ms;
      0001D3 AEr00r0D         [ 2]  446 	ldw	x, #(_btn+0)+5
                                    447 ;	main.c: 136: if (raw == 0u) { /* pressed */
      0001D6 0D 04            [ 1]  448 	tnz	(0x04, sp)
      0001D8 26 11            [ 1]  449 	jrne	00114$
                                    450 ;	main.c: 137: btn.in_press = 1u;
      0001DA 35 01u00u0C      [ 1]  451 	mov	_btn+4, #0x01
                                    452 ;	main.c: 138: btn.press_start_ms = uptime_ms;
      0001DE 90 CEu00u02      [ 2]  453 	ldw	y, _uptime_ms+2
      0001E2 EF 02            [ 2]  454 	ldw	(0x2, x), y
      0001E4 90 CEu00u00      [ 2]  455 	ldw	y, _uptime_ms+0
      0001E8 FF               [ 2]  456 	ldw	(x), y
      0001E9 20 48            [ 2]  457 	jra	00121$
      0001EB                        458 00114$:
                                    459 ;	main.c: 140: if (btn.in_press) {
      0001EB C6u00u0C         [ 1]  460 	ld	a, _btn+4
      0001EE 27 43            [ 1]  461 	jreq	00121$
                                    462 ;	main.c: 141: uint32_t dur_ms = uptime_ms - btn.press_start_ms;
      0001F0 90 93            [ 1]  463 	ldw	y, x
      0001F2 90 EE 02         [ 2]  464 	ldw	y, (0x2, y)
      0001F5 17 03            [ 2]  465 	ldw	(0x03, sp), y
      0001F7 FE               [ 2]  466 	ldw	x, (x)
      0001F8 1F 01            [ 2]  467 	ldw	(0x01, sp), x
      0001FA 90 CEu00u02      [ 2]  468 	ldw	y, _uptime_ms+2
      0001FE 72 F2 03         [ 2]  469 	subw	y, (0x03, sp)
      000201 C6u00u01         [ 1]  470 	ld	a, _uptime_ms+1
      000204 12 02            [ 1]  471 	sbc	a, (0x02, sp)
      000206 97               [ 1]  472 	ld	xl, a
      000207 C6u00u00         [ 1]  473 	ld	a, _uptime_ms+0
      00020A 12 01            [ 1]  474 	sbc	a, (0x01, sp)
      00020C 95               [ 1]  475 	ld	xh, a
                                    476 ;	main.c: 142: btn.in_press = 0u;
      00020D 35 00u00u0C      [ 1]  477 	mov	_btn+4, #0x00
                                    478 ;	main.c: 144: if (dur_ms >= LONG_PRESS_MIN_MS)       btn.long_event  = 1u;
      000211 90 A3 07 D0      [ 2]  479 	cpw	y, #0x07d0
      000215 9F               [ 1]  480 	ld	a, xl
      000216 A2 00            [ 1]  481 	sbc	a, #0x00
      000218 9E               [ 1]  482 	ld	a, xh
      000219 A2 00            [ 1]  483 	sbc	a, #0x00
      00021B 25 06            [ 1]  484 	jrc	00109$
      00021D 35 01u00u12      [ 1]  485 	mov	_btn+10, #0x01
      000221 20 10            [ 2]  486 	jra	00121$
      000223                        487 00109$:
                                    488 ;	main.c: 145: else if (dur_ms <  SHORT_PRESS_MAX_MS) btn.short_event = 1u;
      000223 90 A3 03 E8      [ 2]  489 	cpw	y, #0x03e8
      000227 4F               [ 1]  490 	clr	a
      000228 A2 00            [ 1]  491 	sbc	a, #0x00
      00022A 4F               [ 1]  492 	clr	a
      00022B A2 00            [ 1]  493 	sbc	a, #0x00
      00022D 24 04            [ 1]  494 	jrnc	00121$
      00022F 35 01u00u11      [ 1]  495 	mov	_btn+9, #0x01
      000233                        496 00121$:
                                    497 ;	main.c: 151: }
      000233 5B 04            [ 2]  498 	addw	sp, #4
      000235 81               [ 4]  499 	ret
                                    500 ;	main.c: 154: static void schedule_next_interval(void) {
                                    501 ;	-----------------------------------------
                                    502 ;	 function schedule_next_interval
                                    503 ;	-----------------------------------------
      000236                        504 _schedule_next_interval:
                                    505 ;	main.c: 156: switch (mode) {
      000236 C6u00u13         [ 1]  506 	ld	a, _mode+0
      000239 4A               [ 1]  507 	dec	a
      00023A 27 10            [ 1]  508 	jreq	00101$
      00023C C6u00u13         [ 1]  509 	ld	a, _mode+0
      00023F A1 02            [ 1]  510 	cp	a, #0x02
      000241 27 13            [ 1]  511 	jreq	00102$
      000243 C6u00u13         [ 1]  512 	ld	a, _mode+0
      000246 A1 03            [ 1]  513 	cp	a, #0x03
      000248 27 16            [ 1]  514 	jreq	00103$
      00024A 20 1E            [ 2]  515 	jra	00104$
                                    516 ;	main.c: 157: case MODE_ECO:  interval_s = rand_minutes_range_to_seconds(70, 80); break;
      00024C                        517 00101$:
      00024C 4B 50            [ 1]  518 	push	#0x50
      00024E A6 46            [ 1]  519 	ld	a, #0x46
      000250 CDr00rA4         [ 4]  520 	call	_rand_minutes_range_to_seconds
      000253 84               [ 1]  521 	pop	a
      000254 20 17            [ 2]  522 	jra	00105$
                                    523 ;	main.c: 158: case MODE_MID:  interval_s = rand_minutes_range_to_seconds(55, 65); break;
      000256                        524 00102$:
      000256 4B 41            [ 1]  525 	push	#0x41
      000258 A6 37            [ 1]  526 	ld	a, #0x37
      00025A CDr00rA4         [ 4]  527 	call	_rand_minutes_range_to_seconds
      00025D 84               [ 1]  528 	pop	a
      00025E 20 0D            [ 2]  529 	jra	00105$
                                    530 ;	main.c: 159: case MODE_HIGH: interval_s = rand_minutes_range_to_seconds(40, 50); break;
      000260                        531 00103$:
      000260 4B 32            [ 1]  532 	push	#0x32
      000262 A6 28            [ 1]  533 	ld	a, #0x28
      000264 CDr00rA4         [ 4]  534 	call	_rand_minutes_range_to_seconds
      000267 84               [ 1]  535 	pop	a
      000268 20 03            [ 2]  536 	jra	00105$
                                    537 ;	main.c: 160: default: interval_s = 0; break;
      00026A                        538 00104$:
      00026A 5F               [ 1]  539 	clrw	x
      00026B 90 5F            [ 1]  540 	clrw	y
                                    541 ;	main.c: 161: }
      00026D                        542 00105$:
                                    543 ;	main.c: 162: next_on_time_s = uptime_s + interval_s;
      00026D 72 BBu00u06      [ 2]  544 	addw	x, _uptime_s+2
      000271 90 9F            [ 1]  545 	ld	a, yl
      000273 C9u00u05         [ 1]  546 	adc	a, _uptime_s+1
      000276 90 02            [ 1]  547 	rlwa	y
      000278 C9u00u04         [ 1]  548 	adc	a, _uptime_s+0
      00027B 90 95            [ 1]  549 	ld	yh, a
      00027D CFu00u1B         [ 2]  550 	ldw	_next_on_time_s+2, x
      000280 90 CFu00u19      [ 2]  551 	ldw	_next_on_time_s+0, y
                                    552 ;	main.c: 163: }
      000284 81               [ 4]  553 	ret
                                    554 ;	main.c: 166: static void clock_init(void) {
                                    555 ;	-----------------------------------------
                                    556 ;	 function clock_init
                                    557 ;	-----------------------------------------
      000285                        558 _clock_init:
                                    559 ;	main.c: 167: CLK_HSIPrescalerConfig(CLK_PRESCALER_HSIDIV1);
      000285 4F               [ 1]  560 	clr	a
      000286 CDr00r00         [ 4]  561 	call	_CLK_HSIPrescalerConfig
                                    562 ;	main.c: 168: CLK_PeripheralClockConfig(CLK_PERIPHERAL_TIMER4, ENABLE);
      000289 4B 01            [ 1]  563 	push	#0x01
      00028B A6 04            [ 1]  564 	ld	a, #0x04
      00028D CDr00r00         [ 4]  565 	call	_CLK_PeripheralClockConfig
                                    566 ;	main.c: 169: }
      000290 81               [ 4]  567 	ret
                                    568 ;	main.c: 171: static void gpio_init(void) {
                                    569 ;	-----------------------------------------
                                    570 ;	 function gpio_init
                                    571 ;	-----------------------------------------
      000291                        572 _gpio_init:
                                    573 ;	main.c: 173: GPIO_DeInit(FAN_PORT);
      000291 AE 50 0F         [ 2]  574 	ldw	x, #0x500f
      000294 CDr00r00         [ 4]  575 	call	_GPIO_DeInit
                                    576 ;	main.c: 174: GPIO_Init(FAN_PORT, FAN_PIN, GPIO_MODE_OUT_PP_LOW_FAST);
      000297 4B E0            [ 1]  577 	push	#0xe0
      000299 A6 10            [ 1]  578 	ld	a, #0x10
      00029B AE 50 0F         [ 2]  579 	ldw	x, #0x500f
      00029E CDr00r00         [ 4]  580 	call	_GPIO_Init
                                    581 ;	main.c: 177: GPIO_DeInit(LED_R_PORT);
      0002A1 AE 50 0A         [ 2]  582 	ldw	x, #0x500a
      0002A4 CDr00r00         [ 4]  583 	call	_GPIO_DeInit
                                    584 ;	main.c: 178: GPIO_Init(LED_R_PORT, LED_R_PIN, GPIO_MODE_OUT_PP_HIGH_FAST);
      0002A7 4B F0            [ 1]  585 	push	#0xf0
      0002A9 A6 80            [ 1]  586 	ld	a, #0x80
      0002AB AE 50 0A         [ 2]  587 	ldw	x, #0x500a
      0002AE CDr00r00         [ 4]  588 	call	_GPIO_Init
                                    589 ;	main.c: 179: GPIO_DeInit(LED_G_PORT);
      0002B1 AE 50 0A         [ 2]  590 	ldw	x, #0x500a
      0002B4 CDr00r00         [ 4]  591 	call	_GPIO_DeInit
                                    592 ;	main.c: 180: GPIO_Init(LED_G_PORT, LED_G_PIN, GPIO_MODE_OUT_PP_HIGH_FAST);
      0002B7 4B F0            [ 1]  593 	push	#0xf0
      0002B9 A6 40            [ 1]  594 	ld	a, #0x40
      0002BB AE 50 0A         [ 2]  595 	ldw	x, #0x500a
      0002BE CDr00r00         [ 4]  596 	call	_GPIO_Init
                                    597 ;	main.c: 181: GPIO_DeInit(LED_B_PORT);
      0002C1 AE 50 0A         [ 2]  598 	ldw	x, #0x500a
      0002C4 CDr00r00         [ 4]  599 	call	_GPIO_DeInit
                                    600 ;	main.c: 182: GPIO_Init(LED_B_PORT, LED_B_PIN, GPIO_MODE_OUT_PP_HIGH_FAST);
      0002C7 4B F0            [ 1]  601 	push	#0xf0
      0002C9 A6 20            [ 1]  602 	ld	a, #0x20
      0002CB AE 50 0A         [ 2]  603 	ldw	x, #0x500a
      0002CE CDr00r00         [ 4]  604 	call	_GPIO_Init
                                    605 ;	main.c: 185: GPIO_DeInit(BTN_PORT);
      0002D1 AE 50 05         [ 2]  606 	ldw	x, #0x5005
      0002D4 CDr00r00         [ 4]  607 	call	_GPIO_DeInit
                                    608 ;	main.c: 186: GPIO_Init(BTN_PORT, BTN_PIN, GPIO_MODE_IN_PU_NO_IT);
      0002D7 4B 40            [ 1]  609 	push	#0x40
      0002D9 A6 10            [ 1]  610 	ld	a, #0x10
      0002DB AE 50 05         [ 2]  611 	ldw	x, #0x5005
      0002DE CDr00r00         [ 4]  612 	call	_GPIO_Init
                                    613 ;	main.c: 187: }
      0002E1 81               [ 4]  614 	ret
                                    615 ;	main.c: 189: static void tim4_init_1ms(void) {
                                    616 ;	-----------------------------------------
                                    617 ;	 function tim4_init_1ms
                                    618 ;	-----------------------------------------
      0002E2                        619 _tim4_init_1ms:
                                    620 ;	main.c: 191: TIM4_TimeBaseInit(TIM4_PRESCALER_128, 125 - 1);
      0002E2 4B 7C            [ 1]  621 	push	#0x7c
      0002E4 A6 07            [ 1]  622 	ld	a, #0x07
      0002E6 CDr00r00         [ 4]  623 	call	_TIM4_TimeBaseInit
                                    624 ;	main.c: 192: TIM4_SetCounter(0);
      0002E9 4F               [ 1]  625 	clr	a
      0002EA CDr00r00         [ 4]  626 	call	_TIM4_SetCounter
                                    627 ;	main.c: 193: TIM4_ClearFlag(TIM4_FLAG_UPDATE);
      0002ED A6 01            [ 1]  628 	ld	a, #0x01
      0002EF CDr00r00         [ 4]  629 	call	_TIM4_ClearFlag
                                    630 ;	main.c: 194: TIM4_Cmd(ENABLE);
      0002F2 A6 01            [ 1]  631 	ld	a, #0x01
                                    632 ;	main.c: 195: }
      0002F4 CCr00r00         [ 2]  633 	jp	_TIM4_Cmd
                                    634 ;	main.c: 197: static void wwdg_init(void) {
                                    635 ;	-----------------------------------------
                                    636 ;	 function wwdg_init
                                    637 ;	-----------------------------------------
      0002F7                        638 _wwdg_init:
                                    639 ;	main.c: 198: WWDG_Init(WWDG_START_COUNTER, WWDG_WINDOW);
      0002F7 4B 50            [ 1]  640 	push	#0x50
      0002F9 A6 7F            [ 1]  641 	ld	a, #0x7f
      0002FB CDr00r00         [ 4]  642 	call	_WWDG_Init
                                    643 ;	main.c: 199: }
      0002FE 81               [ 4]  644 	ret
                                    645 ;	main.c: 202: static inline void wwdg_service(void) {
                                    646 ;	-----------------------------------------
                                    647 ;	 function wwdg_service
                                    648 ;	-----------------------------------------
      0002FF                        649 _wwdg_service:
                                    650 ;	main.c: 203: uint8_t c = (uint8_t)(WWDG_GetCounter() & 0x7F);
      0002FF CDr00r00         [ 4]  651 	call	_WWDG_GetCounter
      000302 A4 7F            [ 1]  652 	and	a, #0x7f
                                    653 ;	main.c: 204: if ((c < WWDG_WINDOW) && (c >= WWDG_REFRESH_FLOOR)) {
      000304 A1 50            [ 1]  654 	cp	a, #0x50
      000306 25 01            [ 1]  655 	jrc	00120$
      000308 81               [ 4]  656 	ret
      000309                        657 00120$:
      000309 A1 44            [ 1]  658 	cp	a, #0x44
      00030B 24 01            [ 1]  659 	jrnc	00121$
      00030D 81               [ 4]  660 	ret
      00030E                        661 00121$:
                                    662 ;	main.c: 205: WWDG_SetCounter(WWDG_START_COUNTER);
      00030E A6 7F            [ 1]  663 	ld	a, #0x7f
                                    664 ;	main.c: 207: }
      000310 CCr00r00         [ 2]  665 	jp	_WWDG_SetCounter
                                    666 ;	main.c: 210: static void enter_mode(mode_t m) {
                                    667 ;	-----------------------------------------
                                    668 ;	 function enter_mode
                                    669 ;	-----------------------------------------
      000313                        670 _enter_mode:
                                    671 ;	main.c: 213: switch (mode) {
      000313 C7u00u13         [ 1]  672 	ld	_mode+0, a
      000316 27 15            [ 1]  673 	jreq	00101$
      000318 C6u00u13         [ 1]  674 	ld	a, _mode+0
      00031B 4A               [ 1]  675 	dec	a
      00031C 27 1E            [ 1]  676 	jreq	00104$
      00031E C6u00u13         [ 1]  677 	ld	a, _mode+0
      000321 A1 02            [ 1]  678 	cp	a, #0x02
      000323 27 17            [ 1]  679 	jreq	00104$
      000325 C6u00u13         [ 1]  680 	ld	a, _mode+0
      000328 A1 03            [ 1]  681 	cp	a, #0x03
      00032A 27 10            [ 1]  682 	jreq	00104$
      00032C 81               [ 4]  683 	ret
                                    684 ;	main.c: 214: case MODE_OFF:
      00032D                        685 00101$:
                                    686 ;	main.c: 96: static inline void fan_off(void)  { GPIO_WriteLow (FAN_PORT, FAN_PIN);  fan_on = 0; }
      00032D A6 10            [ 1]  687 	ld	a, #0x10
      00032F AE 50 0F         [ 2]  688 	ldw	x, #0x500f
      000332 CDr00r00         [ 4]  689 	call	_GPIO_WriteLow
      000335 72 5Fu00u14      [ 1]  690 	clr	_fan_on+0
                                    691 ;	main.c: 216: led_off_all();
                                    692 ;	main.c: 217: break;
      000339 CCr01r35         [ 2]  693 	jp	_led_off_all
                                    694 ;	main.c: 221: case MODE_HIGH:
      00033C                        695 00104$:
                                    696 ;	main.c: 223: led_set_for_mode(mode);
      00033C C6u00u13         [ 1]  697 	ld	a, _mode+0
      00033F CDr01r4D         [ 4]  698 	call	_led_set_for_mode
                                    699 ;	main.c: 96: static inline void fan_off(void)  { GPIO_WriteLow (FAN_PORT, FAN_PIN);  fan_on = 0; }
      000342 A6 10            [ 1]  700 	ld	a, #0x10
      000344 AE 50 0F         [ 2]  701 	ldw	x, #0x500f
      000347 CDr00r00         [ 4]  702 	call	_GPIO_WriteLow
      00034A 72 5Fu00u14      [ 1]  703 	clr	_fan_on+0
                                    704 ;	main.c: 225: schedule_next_interval();
                                    705 ;	main.c: 227: }
                                    706 ;	main.c: 228: }
      00034E CCr02r36         [ 2]  707 	jp	_schedule_next_interval
                                    708 ;	main.c: 231: static void advance_mode(void) {
                                    709 ;	-----------------------------------------
                                    710 ;	 function advance_mode
                                    711 ;	-----------------------------------------
      000351                        712 _advance_mode:
                                    713 ;	main.c: 232: switch (mode) {
      000351 C6u00u13         [ 1]  714 	ld	a, _mode+0
      000354 27 15            [ 1]  715 	jreq	00101$
      000356 C6u00u13         [ 1]  716 	ld	a, _mode+0
      000359 4A               [ 1]  717 	dec	a
      00035A 27 14            [ 1]  718 	jreq	00102$
      00035C C6u00u13         [ 1]  719 	ld	a, _mode+0
      00035F A1 02            [ 1]  720 	cp	a, #0x02
      000361 27 12            [ 1]  721 	jreq	00103$
      000363 C6u00u13         [ 1]  722 	ld	a, _mode+0
      000366 A1 03            [ 1]  723 	cp	a, #0x03
      000368 27 10            [ 1]  724 	jreq	00104$
      00036A 81               [ 4]  725 	ret
                                    726 ;	main.c: 233: case MODE_OFF:  enter_mode(MODE_ECO);  break;
      00036B                        727 00101$:
      00036B A6 01            [ 1]  728 	ld	a, #0x01
      00036D CCr03r13         [ 2]  729 	jp	_enter_mode
                                    730 ;	main.c: 234: case MODE_ECO:  enter_mode(MODE_MID);  break;
      000370                        731 00102$:
      000370 A6 02            [ 1]  732 	ld	a, #0x02
      000372 CCr03r13         [ 2]  733 	jp	_enter_mode
                                    734 ;	main.c: 235: case MODE_MID:  enter_mode(MODE_HIGH); break;
      000375                        735 00103$:
      000375 A6 03            [ 1]  736 	ld	a, #0x03
      000377 CCr03r13         [ 2]  737 	jp	_enter_mode
                                    738 ;	main.c: 236: case MODE_HIGH: enter_mode(MODE_OFF);  break;
      00037A                        739 00104$:
      00037A 4F               [ 1]  740 	clr	a
                                    741 ;	main.c: 237: }
                                    742 ;	main.c: 238: }
      00037B CCr03r13         [ 2]  743 	jp	_enter_mode
                                    744 ;	main.c: 241: int main(void) {
                                    745 ;	-----------------------------------------
                                    746 ;	 function main
                                    747 ;	-----------------------------------------
      00037E                        748 _main:
      00037E 52 04            [ 2]  749 	sub	sp, #4
                                    750 ;	main.c: 242: clock_init();
      000380 CDr02r85         [ 4]  751 	call	_clock_init
                                    752 ;	main.c: 243: gpio_init();
      000383 CDr02r91         [ 4]  753 	call	_gpio_init
                                    754 ;	main.c: 244: tim4_init_1ms();
      000386 CDr02rE2         [ 4]  755 	call	_tim4_init_1ms
                                    756 ;	main.c: 245: wwdg_init();
      000389 CDr02rF7         [ 4]  757 	call	_wwdg_init
                                    758 ;	main.c: 248: enter_mode(MODE_OFF);
      00038C 4F               [ 1]  759 	clr	a
      00038D CDr03r13         [ 4]  760 	call	_enter_mode
                                    761 ;	main.c: 251: lfsr ^= (uint16_t)TIM4->CNTR;
      000390 C6 53 46         [ 1]  762 	ld	a, 0x5346
      000393 C8u00u1E         [ 1]  763 	xor	a, _lfsr+1
      000396 97               [ 1]  764 	ld	xl, a
      000397 4F               [ 1]  765 	clr	a
      000398 C8u00u1D         [ 1]  766 	xor	a, _lfsr+0
      00039B 95               [ 1]  767 	ld	xh, a
      00039C CFu00u1D         [ 2]  768 	ldw	_lfsr+0, x
                                    769 ;	main.c: 253: uint32_t last_ms = 0;
      00039F 5F               [ 1]  770 	clrw	x
      0003A0 1F 03            [ 2]  771 	ldw	(0x03, sp), x
      0003A2 1F 01            [ 2]  772 	ldw	(0x01, sp), x
      0003A4                        773 00137$:
                                    774 ;	main.c: 70: if (TIM4_GetFlagStatus(TIM4_FLAG_UPDATE) != RESET) {
      0003A4 A6 01            [ 1]  775 	ld	a, #0x01
      0003A6 CDr00r00         [ 4]  776 	call	_TIM4_GetFlagStatus
      0003A9 4D               [ 1]  777 	tnz	a
      0003AA 27 49            [ 1]  778 	jreq	00129$
                                    779 ;	main.c: 71: TIM4_ClearFlag(TIM4_FLAG_UPDATE);
      0003AC A6 01            [ 1]  780 	ld	a, #0x01
      0003AE CDr00r00         [ 4]  781 	call	_TIM4_ClearFlag
                                    782 ;	main.c: 72: uptime_ms++;
      0003B1 CEu00u02         [ 2]  783 	ldw	x, _uptime_ms+2
      0003B4 90 CEu00u00      [ 2]  784 	ldw	y, _uptime_ms+0
      0003B8 5C               [ 1]  785 	incw	x
      0003B9 26 02            [ 1]  786 	jrne	00247$
      0003BB 90 5C            [ 1]  787 	incw	y
      0003BD                        788 00247$:
      0003BD CFu00u02         [ 2]  789 	ldw	_uptime_ms+2, x
      0003C0 90 CFu00u00      [ 2]  790 	ldw	_uptime_ms+0, y
                                    791 ;	main.c: 73: if ((uptime_ms % MS_PER_SEC) == 0u) {
      0003C4 4B E8            [ 1]  792 	push	#0xe8
      0003C6 4B 03            [ 1]  793 	push	#0x03
      0003C8 5F               [ 1]  794 	clrw	x
      0003C9 89               [ 2]  795 	pushw	x
      0003CA 3Bu00u03         [ 1]  796 	push	_uptime_ms+3
      0003CD 3Bu00u02         [ 1]  797 	push	_uptime_ms+2
      0003D0 3Bu00u01         [ 1]  798 	push	_uptime_ms+1
      0003D3 3Bu00u00         [ 1]  799 	push	_uptime_ms+0
      0003D6 CDr00r00         [ 4]  800 	call	__modulong
      0003D9 5B 08            [ 2]  801 	addw	sp, #8
      0003DB 5D               [ 2]  802 	tnzw	x
      0003DC 26 17            [ 1]  803 	jrne	00129$
      0003DE 90 5D            [ 2]  804 	tnzw	y
      0003E0 26 13            [ 1]  805 	jrne	00129$
                                    806 ;	main.c: 74: uptime_s++;
      0003E2 CEu00u06         [ 2]  807 	ldw	x, _uptime_s+2
      0003E5 90 CEu00u04      [ 2]  808 	ldw	y, _uptime_s+0
      0003E9 5C               [ 1]  809 	incw	x
      0003EA 26 02            [ 1]  810 	jrne	00250$
      0003EC 90 5C            [ 1]  811 	incw	y
      0003EE                        812 00250$:
      0003EE CFu00u06         [ 2]  813 	ldw	_uptime_s+2, x
      0003F1 90 CFu00u04      [ 2]  814 	ldw	_uptime_s+0, y
                                    815 ;	main.c: 257: tick_1ms_poll();
      0003F5                        816 00129$:
                                    817 ;	main.c: 260: if (uptime_ms != last_ms) {
      0003F5 1E 03            [ 2]  818 	ldw	x, (0x03, sp)
      0003F7 C3u00u02         [ 2]  819 	cpw	x, _uptime_ms+2
      0003FA 26 0A            [ 1]  820 	jrne	00252$
      0003FC 1E 01            [ 2]  821 	ldw	x, (0x01, sp)
      0003FE C3u00u00         [ 2]  822 	cpw	x, _uptime_ms+0
      000401 26 03            [ 1]  823 	jrne	00252$
      000403 CCr04rDC         [ 2]  824 	jp	00123$
      000406                        825 00252$:
                                    826 ;	main.c: 261: last_ms = uptime_ms;
      000406 CEu00u02         [ 2]  827 	ldw	x, _uptime_ms+2
      000409 1F 03            [ 2]  828 	ldw	(0x03, sp), x
      00040B CEu00u00         [ 2]  829 	ldw	x, _uptime_ms+0
      00040E 1F 01            [ 2]  830 	ldw	(0x01, sp), x
                                    831 ;	main.c: 264: button_update_1ms();
      000410 CDr01r87         [ 4]  832 	call	_button_update_1ms
                                    833 ;	main.c: 267: if (btn.long_event) {
      000413 C6u00u12         [ 1]  834 	ld	a, _btn+10
      000416 27 0A            [ 1]  835 	jreq	00104$
                                    836 ;	main.c: 268: btn.long_event = 0u;
      000418 35 00u00u12      [ 1]  837 	mov	_btn+10, #0x00
                                    838 ;	main.c: 269: enter_mode(MODE_OFF);                 /* Long press => OFF */
      00041C 4F               [ 1]  839 	clr	a
      00041D CDr03r13         [ 4]  840 	call	_enter_mode
      000420 20 0C            [ 2]  841 	jra	00105$
      000422                        842 00104$:
                                    843 ;	main.c: 270: } else if (btn.short_event) {
      000422 C6u00u11         [ 1]  844 	ld	a, _btn+9
      000425 27 07            [ 1]  845 	jreq	00105$
                                    846 ;	main.c: 271: btn.short_event = 0u;
      000427 35 00u00u11      [ 1]  847 	mov	_btn+9, #0x00
                                    848 ;	main.c: 272: advance_mode();                        /* Short press => next mode, LED updates immediately */
      00042B CDr03r51         [ 4]  849 	call	_advance_mode
      00042E                        850 00105$:
                                    851 ;	main.c: 276: if ((uptime_ms % MS_PER_SEC) == 0u) {
      00042E 4B E8            [ 1]  852 	push	#0xe8
      000430 4B 03            [ 1]  853 	push	#0x03
      000432 5F               [ 1]  854 	clrw	x
      000433 89               [ 2]  855 	pushw	x
      000434 3Bu00u03         [ 1]  856 	push	_uptime_ms+3
      000437 3Bu00u02         [ 1]  857 	push	_uptime_ms+2
      00043A 3Bu00u01         [ 1]  858 	push	_uptime_ms+1
      00043D 3Bu00u00         [ 1]  859 	push	_uptime_ms+0
      000440 CDr00r00         [ 4]  860 	call	__modulong
      000443 5B 08            [ 2]  861 	addw	sp, #8
      000445 5D               [ 2]  862 	tnzw	x
      000446 26 04            [ 1]  863 	jrne	00256$
      000448 90 5D            [ 2]  864 	tnzw	y
      00044A 27 03            [ 1]  865 	jreq	00257$
      00044C                        866 00256$:
      00044C CCr04rDC         [ 2]  867 	jp	00123$
      00044F                        868 00257$:
                                    869 ;	main.c: 277: if (mode == MODE_ECO || mode == MODE_MID || mode == MODE_HIGH) {
      00044F C6u00u13         [ 1]  870 	ld	a, _mode+0
      000452 4A               [ 1]  871 	dec	a
      000453 27 0E            [ 1]  872 	jreq	00115$
      000455 C6u00u13         [ 1]  873 	ld	a, _mode+0
      000458 A1 02            [ 1]  874 	cp	a, #0x02
      00045A 27 07            [ 1]  875 	jreq	00115$
      00045C C6u00u13         [ 1]  876 	ld	a, _mode+0
      00045F A1 03            [ 1]  877 	cp	a, #0x03
      000461 26 68            [ 1]  878 	jrne	00116$
      000463                        879 00115$:
                                    880 ;	main.c: 278: if (fan_on) {
      000463 C6u00u14         [ 1]  881 	ld	a, _fan_on+0
      000466 27 33            [ 1]  882 	jreq	00111$
                                    883 ;	main.c: 280: if ((uptime_s - fan_on_started_s) >= FAN_ON_DURATION_S) {
      000468 CEu00u06         [ 2]  884 	ldw	x, _uptime_s+2
      00046B 72 B0u00u17      [ 2]  885 	subw	x, _fan_on_started_s+2
      00046F C6u00u05         [ 1]  886 	ld	a, _uptime_s+1
      000472 C2u00u16         [ 1]  887 	sbc	a, _fan_on_started_s+1
      000475 90 97            [ 1]  888 	ld	yl, a
      000477 C6u00u04         [ 1]  889 	ld	a, _uptime_s+0
      00047A C2u00u15         [ 1]  890 	sbc	a, _fan_on_started_s+0
      00047D 88               [ 1]  891 	push	a
      00047E A3 01 2C         [ 2]  892 	cpw	x, #0x012c
      000481 90 9F            [ 1]  893 	ld	a, yl
      000483 A2 00            [ 1]  894 	sbc	a, #0x00
      000485 84               [ 1]  895 	pop	a
      000486 A2 00            [ 1]  896 	sbc	a, #0x00
      000488 25 52            [ 1]  897 	jrc	00123$
                                    898 ;	main.c: 96: static inline void fan_off(void)  { GPIO_WriteLow (FAN_PORT, FAN_PIN);  fan_on = 0; }
      00048A A6 10            [ 1]  899 	ld	a, #0x10
      00048C AE 50 0F         [ 2]  900 	ldw	x, #0x500f
      00048F CDr00r00         [ 4]  901 	call	_GPIO_WriteLow
      000492 72 5Fu00u14      [ 1]  902 	clr	_fan_on+0
                                    903 ;	main.c: 282: schedule_next_interval();        /* pick new jitter for the next interval */
      000496 CDr02r36         [ 4]  904 	call	_schedule_next_interval
      000499 20 41            [ 2]  905 	jra	00123$
      00049B                        906 00111$:
                                    907 ;	main.c: 286: if (uptime_s >= next_on_time_s) {
      00049B CEu00u06         [ 2]  908 	ldw	x, _uptime_s+2
      00049E C3u00u1B         [ 2]  909 	cpw	x, _next_on_time_s+2
      0004A1 C6u00u05         [ 1]  910 	ld	a, _uptime_s+1
      0004A4 C2u00u1A         [ 1]  911 	sbc	a, _next_on_time_s+1
      0004A7 C6u00u04         [ 1]  912 	ld	a, _uptime_s+0
      0004AA C2u00u19         [ 1]  913 	sbc	a, _next_on_time_s+0
      0004AD 25 2D            [ 1]  914 	jrc	00123$
                                    915 ;	main.c: 97: static inline void fan_on_fn(void){ GPIO_WriteHigh(FAN_PORT, FAN_PIN);  fan_on = 1; fan_on_started_s = uptime_s; }
      0004AF A6 10            [ 1]  916 	ld	a, #0x10
      0004B1 AE 50 0F         [ 2]  917 	ldw	x, #0x500f
      0004B4 CDr00r00         [ 4]  918 	call	_GPIO_WriteHigh
      0004B7 35 01u00u14      [ 1]  919 	mov	_fan_on+0, #0x01
      0004BB CEu00u06         [ 2]  920 	ldw	x, _uptime_s+2
      0004BE 90 CEu00u04      [ 2]  921 	ldw	y, _uptime_s+0
      0004C2 CFu00u17         [ 2]  922 	ldw	_fan_on_started_s+2, x
      0004C5 90 CFu00u15      [ 2]  923 	ldw	_fan_on_started_s+0, y
                                    924 ;	main.c: 287: fan_on_fn();
      0004C9 20 11            [ 2]  925 	jra	00123$
      0004CB                        926 00116$:
                                    927 ;	main.c: 292: if (fan_on) fan_off();
      0004CB C6u00u14         [ 1]  928 	ld	a, _fan_on+0
      0004CE 27 0C            [ 1]  929 	jreq	00123$
                                    930 ;	main.c: 96: static inline void fan_off(void)  { GPIO_WriteLow (FAN_PORT, FAN_PIN);  fan_on = 0; }
      0004D0 A6 10            [ 1]  931 	ld	a, #0x10
      0004D2 AE 50 0F         [ 2]  932 	ldw	x, #0x500f
      0004D5 CDr00r00         [ 4]  933 	call	_GPIO_WriteLow
      0004D8 72 5Fu00u14      [ 1]  934 	clr	_fan_on+0
                                    935 ;	main.c: 292: if (fan_on) fan_off();
      0004DC                        936 00123$:
                                    937 ;	main.c: 203: uint8_t c = (uint8_t)(WWDG_GetCounter() & 0x7F);
      0004DC CDr00r00         [ 4]  938 	call	_WWDG_GetCounter
      0004DF A4 7F            [ 1]  939 	and	a, #0x7f
                                    940 ;	main.c: 204: if ((c < WWDG_WINDOW) && (c >= WWDG_REFRESH_FLOOR)) {
      0004E1 A1 50            [ 1]  941 	cp	a, #0x50
      0004E3 25 03            [ 1]  942 	jrc	00271$
      0004E5 CCr03rA4         [ 2]  943 	jp	00137$
      0004E8                        944 00271$:
      0004E8 A1 44            [ 1]  945 	cp	a, #0x44
      0004EA 24 03            [ 1]  946 	jrnc	00272$
      0004EC CCr03rA4         [ 2]  947 	jp	00137$
      0004EF                        948 00272$:
                                    949 ;	main.c: 205: WWDG_SetCounter(WWDG_START_COUNTER);
      0004EF A6 7F            [ 1]  950 	ld	a, #0x7f
      0004F1 CDr00r00         [ 4]  951 	call	_WWDG_SetCounter
                                    952 ;	main.c: 298: wwdg_service();
                                    953 ;	main.c: 300: }
      0004F4 CCr03rA4         [ 2]  954 	jp	00137$
                                    955 	.area CODE
                                    956 	.area CONST
                                    957 	.area INITIALIZER
      000000                        958 __xinit__uptime_ms:
      000000 00 00 00 00            959 	.byte #0x00, #0x00, #0x00, #0x00	; 0
      000004                        960 __xinit__uptime_s:
      000004 00 00 00 00            961 	.byte #0x00, #0x00, #0x00, #0x00	; 0
      000008                        962 __xinit__btn:
      000008 01                     963 	.db #0x01	; 1
      000009 01                     964 	.db #0x01	; 1
      00000A 00 00                  965 	.dw #0x0000
      00000C 00                     966 	.db #0x00	; 0
      00000D 00 00 00 00            967 	.byte #0x00, #0x00, #0x00, #0x00	; 0
      000011 00                     968 	.db #0x00	; 0
      000012 00                     969 	.db #0x00	; 0
      000013                        970 __xinit__mode:
      000013 00                     971 	.db #0x00	; 0
      000014                        972 __xinit__fan_on:
      000014 00                     973 	.db #0x00	; 0
      000015                        974 __xinit__fan_on_started_s:
      000015 00 00 00 00            975 	.byte #0x00, #0x00, #0x00, #0x00	; 0
      000019                        976 __xinit__next_on_time_s:
      000019 00 00 00 00            977 	.byte #0x00, #0x00, #0x00, #0x00	; 0
      00001D                        978 __xinit__lfsr:
      00001D AC E1                  979 	.dw #0xace1
                                    980 	.area CABS (ABS)
