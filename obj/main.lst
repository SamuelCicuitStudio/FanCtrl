                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ISO C Compiler
                                      3 ; Version 4.5.0 #15242 (MINGW64)
                                      4 ;--------------------------------------------------------
                                      5 	.module main
                                      6 	
                                      7 ;--------------------------------------------------------
                                      8 ; Public variables in this module
                                      9 ;--------------------------------------------------------
                                     10 	.globl _main
                                     11 	.globl _WWDG_GetCounter
                                     12 	.globl _WWDG_SetCounter
                                     13 	.globl _WWDG_Init
                                     14 	.globl _TIM4_ClearFlag
                                     15 	.globl _TIM4_GetFlagStatus
                                     16 	.globl _TIM4_SetCounter
                                     17 	.globl _TIM4_Cmd
                                     18 	.globl _TIM4_TimeBaseInit
                                     19 	.globl _GPIO_ReadInputPin
                                     20 	.globl _GPIO_WriteLow
                                     21 	.globl _GPIO_WriteHigh
                                     22 	.globl _GPIO_Init
                                     23 	.globl _GPIO_DeInit
                                     24 	.globl _CLK_HSIPrescalerConfig
                                     25 	.globl _CLK_PeripheralClockConfig
                                     26 ;--------------------------------------------------------
                                     27 ; ram data
                                     28 ;--------------------------------------------------------
                                     29 	.area DATA
                                     30 ;--------------------------------------------------------
                                     31 ; ram data
                                     32 ;--------------------------------------------------------
                                     33 	.area INITIALIZED
      000000                         34 _uptime_ms:
      000000                         35 	.ds 4
      000004                         36 _uptime_s:
      000004                         37 	.ds 4
      000008                         38 _btn:
      000008                         39 	.ds 11
      000013                         40 _mode:
      000013                         41 	.ds 1
      000014                         42 _fan_on:
      000014                         43 	.ds 1
      000015                         44 _fan_on_started_s:
      000015                         45 	.ds 4
      000019                         46 _next_on_time_s:
      000019                         47 	.ds 4
      00001D                         48 _lfsr:
      00001D                         49 	.ds 2
                                     50 ;--------------------------------------------------------
                                     51 ; Stack segment in internal ram
                                     52 ;--------------------------------------------------------
                                     53 	.area SSEG
      000000                         54 __start__stack:
      000000                         55 	.ds	1
                                     56 
                                     57 ;--------------------------------------------------------
                                     58 ; absolute external ram data
                                     59 ;--------------------------------------------------------
                                     60 	.area DABS (ABS)
                                     61 
                                     62 ; default segment ordering for linker
                                     63 	.area HOME
                                     64 	.area GSINIT
                                     65 	.area GSFINAL
                                     66 	.area CONST
                                     67 	.area INITIALIZER
                                     68 	.area CODE
                                     69 
                                     70 ;--------------------------------------------------------
                                     71 ; interrupt vector
                                     72 ;--------------------------------------------------------
                                     73 	.area HOME
      000000                         74 __interrupt_vect:
      000000 82v00u00u00             75 	int s_GSINIT ; reset
                                     76 ;--------------------------------------------------------
                                     77 ; global & static initialisations
                                     78 ;--------------------------------------------------------
                                     79 	.area HOME
                                     80 	.area GSINIT
                                     81 	.area GSFINAL
                                     82 	.area GSINIT
      000000 CDr00r00         [ 4]   83 	call	___sdcc_external_startup
      000003 4D               [ 1]   84 	tnz	a
      000004 27 03            [ 1]   85 	jreq	__sdcc_init_data
      000006 CCr00r04         [ 2]   86 	jp	__sdcc_program_startup
      000009                         87 __sdcc_init_data:
                                     88 ; stm8_genXINIT() start
      000009 AEr00r00         [ 2]   89 	ldw x, #l_DATA
      00000C 27 07            [ 1]   90 	jreq	00002$
      00000E                         91 00001$:
      00000E 72 4FuFFuFF      [ 1]   92 	clr (s_DATA - 1, x)
      000012 5A               [ 2]   93 	decw x
      000013 26 F9            [ 1]   94 	jrne	00001$
      000015                         95 00002$:
      000015 AEr00r00         [ 2]   96 	ldw	x, #l_INITIALIZER
      000018 27 09            [ 1]   97 	jreq	00004$
      00001A                         98 00003$:
      00001A D6uFFuFF         [ 1]   99 	ld	a, (s_INITIALIZER - 1, x)
      00001D D7uFFuFF         [ 1]  100 	ld	(s_INITIALIZED - 1, x), a
      000020 5A               [ 2]  101 	decw	x
      000021 26 F7            [ 1]  102 	jrne	00003$
      000023                        103 00004$:
                                    104 ; stm8_genXINIT() end
                                    105 	.area GSFINAL
      000000 CCr00r04         [ 2]  106 	jp	__sdcc_program_startup
                                    107 ;--------------------------------------------------------
                                    108 ; Home
                                    109 ;--------------------------------------------------------
                                    110 	.area HOME
                                    111 	.area HOME
      000004                        112 __sdcc_program_startup:
      000004 CCr03r72         [ 2]  113 	jp	_main
                                    114 ;	return from main will return to caller
                                    115 ;--------------------------------------------------------
                                    116 ; code
                                    117 ;--------------------------------------------------------
                                    118 	.area CODE
                                    119 ;	main.c: 69: static inline void tick_1ms_poll(void) {
                                    120 ;	-----------------------------------------
                                    121 ;	 function tick_1ms_poll
                                    122 ;	-----------------------------------------
      000000                        123 _tick_1ms_poll:
                                    124 ;	main.c: 70: if (TIM4_GetFlagStatus(TIM4_FLAG_UPDATE) != RESET) {
      000000 A6 01            [ 1]  125 	ld	a, #0x01
      000002 CDr00r00         [ 4]  126 	call	_TIM4_GetFlagStatus
      000005 4D               [ 1]  127 	tnz	a
      000006 26 01            [ 1]  128 	jrne	00121$
      000008 81               [ 4]  129 	ret
      000009                        130 00121$:
                                    131 ;	main.c: 71: TIM4_ClearFlag(TIM4_FLAG_UPDATE);
      000009 A6 01            [ 1]  132 	ld	a, #0x01
      00000B CDr00r00         [ 4]  133 	call	_TIM4_ClearFlag
                                    134 ;	main.c: 72: uptime_ms++;
      00000E CEu00u02         [ 2]  135 	ldw	x, _uptime_ms+2
      000011 90 CEu00u00      [ 2]  136 	ldw	y, _uptime_ms+0
      000015 5C               [ 1]  137 	incw	x
      000016 26 02            [ 1]  138 	jrne	00122$
      000018 90 5C            [ 1]  139 	incw	y
      00001A                        140 00122$:
      00001A CFu00u02         [ 2]  141 	ldw	_uptime_ms+2, x
      00001D 90 CFu00u00      [ 2]  142 	ldw	_uptime_ms+0, y
                                    143 ;	main.c: 73: if ((uptime_ms % MS_PER_SEC) == 0u) {
      000021 4B E8            [ 1]  144 	push	#0xe8
      000023 4B 03            [ 1]  145 	push	#0x03
      000025 5F               [ 1]  146 	clrw	x
      000026 89               [ 2]  147 	pushw	x
      000027 3Bu00u03         [ 1]  148 	push	_uptime_ms+3
      00002A 3Bu00u02         [ 1]  149 	push	_uptime_ms+2
      00002D 3Bu00u01         [ 1]  150 	push	_uptime_ms+1
      000030 3Bu00u00         [ 1]  151 	push	_uptime_ms+0
      000033 CDr00r00         [ 4]  152 	call	__modulong
      000036 5B 08            [ 2]  153 	addw	sp, #8
      000038 5D               [ 2]  154 	tnzw	x
      000039 26 04            [ 1]  155 	jrne	00123$
      00003B 90 5D            [ 2]  156 	tnzw	y
      00003D 27 01            [ 1]  157 	jreq	00124$
      00003F                        158 00123$:
      00003F 81               [ 4]  159 	ret
      000040                        160 00124$:
                                    161 ;	main.c: 74: uptime_s++;
      000040 CEu00u06         [ 2]  162 	ldw	x, _uptime_s+2
      000043 90 CEu00u04      [ 2]  163 	ldw	y, _uptime_s+0
      000047 5C               [ 1]  164 	incw	x
      000048 26 02            [ 1]  165 	jrne	00125$
      00004A 90 5C            [ 1]  166 	incw	y
      00004C                        167 00125$:
      00004C CFu00u06         [ 2]  168 	ldw	_uptime_s+2, x
      00004F 90 CFu00u04      [ 2]  169 	ldw	_uptime_s+0, y
                                    170 ;	main.c: 77: }
      000053 81               [ 4]  171 	ret
                                    172 ;	main.c: 80: static inline uint16_t rand16(void) {
                                    173 ;	-----------------------------------------
                                    174 ;	 function rand16
                                    175 ;	-----------------------------------------
      000054                        176 _rand16:
      000054 52 04            [ 2]  177 	sub	sp, #4
                                    178 ;	main.c: 82: uint16_t lsb = (uint16_t)((lfsr ^ (lfsr >> 2) ^ (lfsr >> 3) ^ (lfsr >> 5)) & 1u);
      000056 CEu00u1D         [ 2]  179 	ldw	x, _lfsr+0
      000059 54               [ 2]  180 	srlw	x
      00005A 54               [ 2]  181 	srlw	x
      00005B 9F               [ 1]  182 	ld	a, xl
      00005C C8u00u1E         [ 1]  183 	xor	a, _lfsr+1
      00005F 6B 02            [ 1]  184 	ld	(0x02, sp), a
      000061 9E               [ 1]  185 	ld	a, xh
      000062 C8u00u1D         [ 1]  186 	xor	a, _lfsr+0
      000065 6B 01            [ 1]  187 	ld	(0x01, sp), a
      000067 CEu00u1D         [ 2]  188 	ldw	x, _lfsr+0
      00006A 54               [ 2]  189 	srlw	x
      00006B 54               [ 2]  190 	srlw	x
      00006C 54               [ 2]  191 	srlw	x
      00006D 9F               [ 1]  192 	ld	a, xl
      00006E 18 02            [ 1]  193 	xor	a, (0x02, sp)
      000070 6B 04            [ 1]  194 	ld	(0x04, sp), a
      000072 9E               [ 1]  195 	ld	a, xh
      000073 18 01            [ 1]  196 	xor	a, (0x01, sp)
      000075 6B 03            [ 1]  197 	ld	(0x03, sp), a
      000077 CEu00u1D         [ 2]  198 	ldw	x, _lfsr+0
      00007A A6 20            [ 1]  199 	ld	a, #0x20
      00007C 62               [ 2]  200 	div	x, a
      00007D 9F               [ 1]  201 	ld	a, xl
      00007E 18 04            [ 1]  202 	xor	a, (0x04, sp)
      000080 97               [ 1]  203 	ld	xl, a
      000081 9E               [ 1]  204 	ld	a, xh
      000082 18 03            [ 1]  205 	xor	a, (0x03, sp)
      000084 9F               [ 1]  206 	ld	a, xl
      000085 A4 01            [ 1]  207 	and	a, #0x01
      000087 97               [ 1]  208 	ld	xl, a
                                    209 ;	main.c: 83: lfsr = (uint16_t)((lfsr >> 1) | (lsb << 15));
      000088 90 CEu00u1D      [ 2]  210 	ldw	y, _lfsr+0
      00008C 90 54            [ 2]  211 	srlw	y
      00008E 9F               [ 1]  212 	ld	a, xl
      00008F 5F               [ 1]  213 	clrw	x
      000090 44               [ 1]  214 	srl	a
      000091 56               [ 2]  215 	rrcw	x
      000092 1F 03            [ 2]  216 	ldw	(0x03, sp), x
      000094 90 9E            [ 1]  217 	ld	a, yh
      000096 1A 03            [ 1]  218 	or	a, (0x03, sp)
      000098 90 95            [ 1]  219 	ld	yh, a
      00009A 90 CFu00u1D      [ 2]  220 	ldw	_lfsr+0, y
                                    221 ;	main.c: 84: return lfsr;
      00009E CEu00u1D         [ 2]  222 	ldw	x, _lfsr+0
                                    223 ;	main.c: 85: }
      0000A1 5B 04            [ 2]  224 	addw	sp, #4
      0000A3 81               [ 4]  225 	ret
                                    226 ;	main.c: 88: static uint32_t rand_minutes_range_to_seconds(uint8_t min_min, uint8_t max_min) {
                                    227 ;	-----------------------------------------
                                    228 ;	 function rand_minutes_range_to_seconds
                                    229 ;	-----------------------------------------
      0000A4                        230 _rand_minutes_range_to_seconds:
      0000A4 52 06            [ 2]  231 	sub	sp, #6
      0000A6 6B 06            [ 1]  232 	ld	(0x06, sp), a
                                    233 ;	main.c: 89: uint8_t span = (uint8_t)(max_min - min_min + 1u);
      0000A8 7B 09            [ 1]  234 	ld	a, (0x09, sp)
      0000AA 10 06            [ 1]  235 	sub	a, (0x06, sp)
      0000AC 4C               [ 1]  236 	inc	a
      0000AD 6B 01            [ 1]  237 	ld	(0x01, sp), a
                                    238 ;	main.c: 82: uint16_t lsb = (uint16_t)((lfsr ^ (lfsr >> 2) ^ (lfsr >> 3) ^ (lfsr >> 5)) & 1u);
      0000AF CEu00u1D         [ 2]  239 	ldw	x, _lfsr+0
      0000B2 54               [ 2]  240 	srlw	x
      0000B3 54               [ 2]  241 	srlw	x
      0000B4 9F               [ 1]  242 	ld	a, xl
      0000B5 C8u00u1E         [ 1]  243 	xor	a, _lfsr+1
      0000B8 6B 03            [ 1]  244 	ld	(0x03, sp), a
      0000BA 9E               [ 1]  245 	ld	a, xh
      0000BB C8u00u1D         [ 1]  246 	xor	a, _lfsr+0
      0000BE 6B 02            [ 1]  247 	ld	(0x02, sp), a
      0000C0 CEu00u1D         [ 2]  248 	ldw	x, _lfsr+0
      0000C3 54               [ 2]  249 	srlw	x
      0000C4 54               [ 2]  250 	srlw	x
      0000C5 54               [ 2]  251 	srlw	x
      0000C6 9F               [ 1]  252 	ld	a, xl
      0000C7 18 03            [ 1]  253 	xor	a, (0x03, sp)
      0000C9 6B 05            [ 1]  254 	ld	(0x05, sp), a
      0000CB 9E               [ 1]  255 	ld	a, xh
      0000CC 18 02            [ 1]  256 	xor	a, (0x02, sp)
      0000CE 6B 04            [ 1]  257 	ld	(0x04, sp), a
      0000D0 CEu00u1D         [ 2]  258 	ldw	x, _lfsr+0
      0000D3 A6 20            [ 1]  259 	ld	a, #0x20
      0000D5 62               [ 2]  260 	div	x, a
      0000D6 9F               [ 1]  261 	ld	a, xl
      0000D7 18 05            [ 1]  262 	xor	a, (0x05, sp)
      0000D9 97               [ 1]  263 	ld	xl, a
      0000DA 9E               [ 1]  264 	ld	a, xh
      0000DB 18 04            [ 1]  265 	xor	a, (0x04, sp)
      0000DD 9F               [ 1]  266 	ld	a, xl
      0000DE A4 01            [ 1]  267 	and	a, #0x01
      0000E0 97               [ 1]  268 	ld	xl, a
                                    269 ;	main.c: 90: uint8_t r = (uint8_t)(rand16() % span);
      0000E1 90 CEu00u1D      [ 2]  270 	ldw	y, _lfsr+0
      0000E5 90 54            [ 2]  271 	srlw	y
      0000E7 9F               [ 1]  272 	ld	a, xl
      0000E8 5F               [ 1]  273 	clrw	x
      0000E9 44               [ 1]  274 	srl	a
      0000EA 56               [ 2]  275 	rrcw	x
      0000EB 1F 04            [ 2]  276 	ldw	(0x04, sp), x
      0000ED 90 9E            [ 1]  277 	ld	a, yh
      0000EF 1A 04            [ 1]  278 	or	a, (0x04, sp)
      0000F1 90 95            [ 1]  279 	ld	yh, a
      0000F3 90 CFu00u1D      [ 2]  280 	ldw	_lfsr+0, y
      0000F7 CEu00u1D         [ 2]  281 	ldw	x, _lfsr+0
      0000FA 7B 01            [ 1]  282 	ld	a, (0x01, sp)
      0000FC 90 5F            [ 1]  283 	clrw	y
      0000FE 90 97            [ 1]  284 	ld	yl, a
      000100 65               [ 2]  285 	divw	x, y
      000101 93               [ 1]  286 	ldw	x, y
                                    287 ;	main.c: 91: uint8_t minutes = (uint8_t)(min_min + r);
      000102 72 FB 05         [ 2]  288 	addw	x, (5, sp)
                                    289 ;	main.c: 92: return (uint32_t)minutes * 60u;
      000105 A6 3C            [ 1]  290 	ld	a, #0x3c
      000107 42               [ 4]  291 	mul	x, a
      000108 90 5F            [ 1]  292 	clrw	y
                                    293 ;	main.c: 93: }
      00010A 5B 06            [ 2]  294 	addw	sp, #6
      00010C 81               [ 4]  295 	ret
                                    296 ;	main.c: 96: static inline void fan_off(void)  { GPIO_WriteLow (FAN_PORT, FAN_PIN);  fan_on = 0; }
                                    297 ;	-----------------------------------------
                                    298 ;	 function fan_off
                                    299 ;	-----------------------------------------
      00010D                        300 _fan_off:
      00010D A6 10            [ 1]  301 	ld	a, #0x10
      00010F AE 50 0F         [ 2]  302 	ldw	x, #0x500f
      000112 CDr00r00         [ 4]  303 	call	_GPIO_WriteLow
      000115 72 5Fu00u14      [ 1]  304 	clr	_fan_on+0
      000119 81               [ 4]  305 	ret
                                    306 ;	main.c: 97: static inline void fan_on_fn(void){ GPIO_WriteHigh(FAN_PORT, FAN_PIN);  fan_on = 1; fan_on_started_s = uptime_s; }
                                    307 ;	-----------------------------------------
                                    308 ;	 function fan_on_fn
                                    309 ;	-----------------------------------------
      00011A                        310 _fan_on_fn:
      00011A A6 10            [ 1]  311 	ld	a, #0x10
      00011C AE 50 0F         [ 2]  312 	ldw	x, #0x500f
      00011F CDr00r00         [ 4]  313 	call	_GPIO_WriteHigh
      000122 35 01u00u14      [ 1]  314 	mov	_fan_on+0, #0x01
      000126 CEu00u06         [ 2]  315 	ldw	x, _uptime_s+2
      000129 90 CEu00u04      [ 2]  316 	ldw	y, _uptime_s+0
      00012D CFu00u17         [ 2]  317 	ldw	_fan_on_started_s+2, x
      000130 90 CFu00u15      [ 2]  318 	ldw	_fan_on_started_s+0, y
      000134 81               [ 4]  319 	ret
                                    320 ;	main.c: 100: static void led_off_all(void) {
                                    321 ;	-----------------------------------------
                                    322 ;	 function led_off_all
                                    323 ;	-----------------------------------------
      000135                        324 _led_off_all:
                                    325 ;	main.c: 101: GPIO_WriteHigh(LED_R_PORT, LED_R_PIN);
      000135 A6 80            [ 1]  326 	ld	a, #0x80
      000137 AE 50 0A         [ 2]  327 	ldw	x, #0x500a
      00013A CDr00r00         [ 4]  328 	call	_GPIO_WriteHigh
                                    329 ;	main.c: 102: GPIO_WriteHigh(LED_G_PORT, LED_G_PIN);
      00013D A6 40            [ 1]  330 	ld	a, #0x40
      00013F AE 50 0A         [ 2]  331 	ldw	x, #0x500a
      000142 CDr00r00         [ 4]  332 	call	_GPIO_WriteHigh
                                    333 ;	main.c: 103: GPIO_WriteHigh(LED_B_PORT, LED_B_PIN);
      000145 A6 20            [ 1]  334 	ld	a, #0x20
      000147 AE 50 0A         [ 2]  335 	ldw	x, #0x500a
                                    336 ;	main.c: 104: }
      00014A CCr00r00         [ 2]  337 	jp	_GPIO_WriteHigh
                                    338 ;	main.c: 106: static void led_set_for_mode(mode_t m) {
                                    339 ;	-----------------------------------------
                                    340 ;	 function led_set_for_mode
                                    341 ;	-----------------------------------------
      00014D                        342 _led_set_for_mode:
                                    343 ;	main.c: 107: led_off_all();
      00014D 88               [ 1]  344 	push	a
      00014E CDr01r35         [ 4]  345 	call	_led_off_all
      000151 84               [ 1]  346 	pop	a
                                    347 ;	main.c: 108: switch (m) {
      000152 A1 01            [ 1]  348 	cp	a, #0x01
      000154 27 09            [ 1]  349 	jreq	00101$
      000156 A1 02            [ 1]  350 	cp	a, #0x02
      000158 27 0D            [ 1]  351 	jreq	00102$
      00015A A1 03            [ 1]  352 	cp	a, #0x03
      00015C 27 11            [ 1]  353 	jreq	00103$
      00015E 81               [ 4]  354 	ret
                                    355 ;	main.c: 109: case MODE_ECO:  GPIO_WriteLow(LED_G_PORT, LED_G_PIN); break; /* Green  */
      00015F                        356 00101$:
      00015F A6 40            [ 1]  357 	ld	a, #0x40
      000161 AE 50 0A         [ 2]  358 	ldw	x, #0x500a
      000164 CCr00r00         [ 2]  359 	jp	_GPIO_WriteLow
                                    360 ;	main.c: 110: case MODE_MID:  GPIO_WriteLow(LED_B_PORT, LED_B_PIN); break; /* Blue   */
      000167                        361 00102$:
      000167 A6 20            [ 1]  362 	ld	a, #0x20
      000169 AE 50 0A         [ 2]  363 	ldw	x, #0x500a
      00016C CCr00r00         [ 2]  364 	jp	_GPIO_WriteLow
                                    365 ;	main.c: 111: case MODE_HIGH: GPIO_WriteLow(LED_R_PORT, LED_R_PIN); break; /* Red    */
      00016F                        366 00103$:
      00016F A6 80            [ 1]  367 	ld	a, #0x80
      000171 AE 50 0A         [ 2]  368 	ldw	x, #0x500a
                                    369 ;	main.c: 113: }
                                    370 ;	main.c: 114: }
      000174 CCr00r00         [ 2]  371 	jp	_GPIO_WriteLow
                                    372 ;	main.c: 117: static inline uint8_t button_raw_level(void) {
                                    373 ;	-----------------------------------------
                                    374 ;	 function button_raw_level
                                    375 ;	-----------------------------------------
      000177                        376 _button_raw_level:
                                    377 ;	main.c: 118: return (uint8_t)GPIO_ReadInputPin(BTN_PORT, BTN_PIN) ? 1u : 0u;
      000177 A6 10            [ 1]  378 	ld	a, #0x10
      000179 AE 50 05         [ 2]  379 	ldw	x, #0x5005
      00017C CDr00r00         [ 4]  380 	call	_GPIO_ReadInputPin
      00017F 4D               [ 1]  381 	tnz	a
      000180 27 03            [ 1]  382 	jreq	00103$
      000182 A6 01            [ 1]  383 	ld	a, #0x01
      000184 81               [ 4]  384 	ret
      000185                        385 00103$:
      000185 4F               [ 1]  386 	clr	a
                                    387 ;	main.c: 119: }
      000186 81               [ 4]  388 	ret
                                    389 ;	main.c: 122: static void button_update_1ms(void) {
                                    390 ;	-----------------------------------------
                                    391 ;	 function button_update_1ms
                                    392 ;	-----------------------------------------
      000187                        393 _button_update_1ms:
      000187 52 04            [ 2]  394 	sub	sp, #4
                                    395 ;	main.c: 123: uint8_t raw = button_raw_level();
      000189 A6 10            [ 1]  396 	ld	a, #0x10
      00018B AE 50 05         [ 2]  397 	ldw	x, #0x5005
      00018E CDr00r00         [ 4]  398 	call	_GPIO_ReadInputPin
      000191 4D               [ 1]  399 	tnz	a
      000192 27 03            [ 1]  400 	jreq	00123$
      000194 A6 01            [ 1]  401 	ld	a, #0x01
      000196 21                     402 	.byte 0x21
      000197                        403 00123$:
      000197 4F               [ 1]  404 	clr	a
      000198                        405 00124$:
      000198 6B 03            [ 1]  406 	ld	(0x03, sp), a
      00019A 6B 04            [ 1]  407 	ld	(0x04, sp), a
                                    408 ;	main.c: 125: if (raw == btn.last_sample) {
      00019C C6u00u09         [ 1]  409 	ld	a, _btn+1
                                    410 ;	main.c: 126: if (btn.stable_time_ms < 0xFFFF) btn.stable_time_ms++;
                                    411 ;	main.c: 125: if (raw == btn.last_sample) {
      00019F 11 03            [ 1]  412 	cp	a, (0x03, sp)
      0001A1 26 11            [ 1]  413 	jrne	00104$
                                    414 ;	main.c: 126: if (btn.stable_time_ms < 0xFFFF) btn.stable_time_ms++;
      0001A3 CEu00u0A         [ 2]  415 	ldw	x, _btn+2
      0001A6 90 93            [ 1]  416 	ldw	y, x
      0001A8 90 A3 FF FF      [ 2]  417 	cpw	y, #0xffff
      0001AC 24 12            [ 1]  418 	jrnc	00105$
      0001AE 5C               [ 1]  419 	incw	x
      0001AF CFu00u0A         [ 2]  420 	ldw	_btn+2, x
      0001B2 20 0C            [ 2]  421 	jra	00105$
      0001B4                        422 00104$:
                                    423 ;	main.c: 128: btn.stable_time_ms = 0;
      0001B4 AEr00r0A         [ 2]  424 	ldw	x, #(_btn+2)
      0001B7 6F 01            [ 1]  425 	clr	(0x1, x)
      0001B9 7F               [ 1]  426 	clr	(x)
                                    427 ;	main.c: 129: btn.last_sample = raw;
      0001BA AEr00r09         [ 2]  428 	ldw	x, #(_btn+1)
      0001BD 7B 03            [ 1]  429 	ld	a, (0x03, sp)
      0001BF F7               [ 1]  430 	ld	(x), a
      0001C0                        431 00105$:
                                    432 ;	main.c: 132: if (btn.stable_time_ms == DEBOUNCE_MS) {
      0001C0 CEu00u0A         [ 2]  433 	ldw	x, _btn+2
      0001C3 A3 00 14         [ 2]  434 	cpw	x, #0x0014
      0001C6 26 6B            [ 1]  435 	jrne	00121$
                                    436 ;	main.c: 133: if (raw != btn.stable_level) {
      0001C8 AEr00r08         [ 2]  437 	ldw	x, #(_btn+0)
      0001CB F6               [ 1]  438 	ld	a, (x)
      0001CC 11 04            [ 1]  439 	cp	a, (0x04, sp)
      0001CE 27 63            [ 1]  440 	jreq	00121$
                                    441 ;	main.c: 134: btn.stable_level = raw;
      0001D0 7B 04            [ 1]  442 	ld	a, (0x04, sp)
      0001D2 F7               [ 1]  443 	ld	(x), a
                                    444 ;	main.c: 137: btn.in_press = 1u;
                                    445 ;	main.c: 138: btn.press_start_ms = uptime_ms;
      0001D3 AEr00r0D         [ 2]  446 	ldw	x, #(_btn+0)+5
                                    447 ;	main.c: 136: if (raw == 0u) { /* pressed */
      0001D6 0D 04            [ 1]  448 	tnz	(0x04, sp)
      0001D8 26 11            [ 1]  449 	jrne	00114$
                                    450 ;	main.c: 137: btn.in_press = 1u;
      0001DA 35 01u00u0C      [ 1]  451 	mov	_btn+4, #0x01
                                    452 ;	main.c: 138: btn.press_start_ms = uptime_ms;
      0001DE 90 CEu00u02      [ 2]  453 	ldw	y, _uptime_ms+2
      0001E2 EF 02            [ 2]  454 	ldw	(0x2, x), y
      0001E4 90 CEu00u00      [ 2]  455 	ldw	y, _uptime_ms+0
      0001E8 FF               [ 2]  456 	ldw	(x), y
      0001E9 20 48            [ 2]  457 	jra	00121$
      0001EB                        458 00114$:
                                    459 ;	main.c: 140: if (btn.in_press) {
      0001EB C6u00u0C         [ 1]  460 	ld	a, _btn+4
      0001EE 27 43            [ 1]  461 	jreq	00121$
                                    462 ;	main.c: 141: uint32_t dur_ms = uptime_ms - btn.press_start_ms;
      0001F0 90 93            [ 1]  463 	ldw	y, x
      0001F2 90 EE 02         [ 2]  464 	ldw	y, (0x2, y)
      0001F5 17 03            [ 2]  465 	ldw	(0x03, sp), y
      0001F7 FE               [ 2]  466 	ldw	x, (x)
      0001F8 1F 01            [ 2]  467 	ldw	(0x01, sp), x
      0001FA 90 CEu00u02      [ 2]  468 	ldw	y, _uptime_ms+2
      0001FE 72 F2 03         [ 2]  469 	subw	y, (0x03, sp)
      000201 C6u00u01         [ 1]  470 	ld	a, _uptime_ms+1
      000204 12 02            [ 1]  471 	sbc	a, (0x02, sp)
      000206 97               [ 1]  472 	ld	xl, a
      000207 C6u00u00         [ 1]  473 	ld	a, _uptime_ms+0
      00020A 12 01            [ 1]  474 	sbc	a, (0x01, sp)
      00020C 95               [ 1]  475 	ld	xh, a
                                    476 ;	main.c: 142: btn.in_press = 0u;
      00020D 35 00u00u0C      [ 1]  477 	mov	_btn+4, #0x00
                                    478 ;	main.c: 144: if (dur_ms >= LONG_PRESS_MIN_MS)       btn.long_event  = 1u;
      000211 90 A3 07 D0      [ 2]  479 	cpw	y, #0x07d0
      000215 9F               [ 1]  480 	ld	a, xl
      000216 A2 00            [ 1]  481 	sbc	a, #0x00
      000218 9E               [ 1]  482 	ld	a, xh
      000219 A2 00            [ 1]  483 	sbc	a, #0x00
      00021B 25 06            [ 1]  484 	jrc	00109$
      00021D 35 01u00u12      [ 1]  485 	mov	_btn+10, #0x01
      000221 20 10            [ 2]  486 	jra	00121$
      000223                        487 00109$:
                                    488 ;	main.c: 145: else if (dur_ms <  SHORT_PRESS_MAX_MS) btn.short_event = 1u;
      000223 90 A3 03 E8      [ 2]  489 	cpw	y, #0x03e8
      000227 4F               [ 1]  490 	clr	a
      000228 A2 00            [ 1]  491 	sbc	a, #0x00
      00022A 4F               [ 1]  492 	clr	a
      00022B A2 00            [ 1]  493 	sbc	a, #0x00
      00022D 24 04            [ 1]  494 	jrnc	00121$
      00022F 35 01u00u11      [ 1]  495 	mov	_btn+9, #0x01
      000233                        496 00121$:
                                    497 ;	main.c: 151: }
      000233 5B 04            [ 2]  498 	addw	sp, #4
      000235 81               [ 4]  499 	ret
                                    500 ;	main.c: 154: static void schedule_next_interval(void) {
                                    501 ;	-----------------------------------------
                                    502 ;	 function schedule_next_interval
                                    503 ;	-----------------------------------------
      000236                        504 _schedule_next_interval:
                                    505 ;	main.c: 156: switch (mode) {
      000236 C6u00u13         [ 1]  506 	ld	a, _mode+0
      000239 4A               [ 1]  507 	dec	a
      00023A 27 10            [ 1]  508 	jreq	00101$
      00023C C6u00u13         [ 1]  509 	ld	a, _mode+0
      00023F A1 02            [ 1]  510 	cp	a, #0x02
      000241 27 13            [ 1]  511 	jreq	00102$
      000243 C6u00u13         [ 1]  512 	ld	a, _mode+0
      000246 A1 03            [ 1]  513 	cp	a, #0x03
      000248 27 16            [ 1]  514 	jreq	00103$
      00024A 20 1E            [ 2]  515 	jra	00104$
                                    516 ;	main.c: 157: case MODE_ECO:  interval_s = rand_minutes_range_to_seconds(70, 80); break;
      00024C                        517 00101$:
      00024C 4B 50            [ 1]  518 	push	#0x50
      00024E A6 46            [ 1]  519 	ld	a, #0x46
      000250 CDr00rA4         [ 4]  520 	call	_rand_minutes_range_to_seconds
      000253 84               [ 1]  521 	pop	a
      000254 20 17            [ 2]  522 	jra	00105$
                                    523 ;	main.c: 158: case MODE_MID:  interval_s = rand_minutes_range_to_seconds(55, 65); break;
      000256                        524 00102$:
      000256 4B 41            [ 1]  525 	push	#0x41
      000258 A6 37            [ 1]  526 	ld	a, #0x37
      00025A CDr00rA4         [ 4]  527 	call	_rand_minutes_range_to_seconds
      00025D 84               [ 1]  528 	pop	a
      00025E 20 0D            [ 2]  529 	jra	00105$
                                    530 ;	main.c: 159: case MODE_HIGH: interval_s = rand_minutes_range_to_seconds(40, 50); break;
      000260                        531 00103$:
      000260 4B 32            [ 1]  532 	push	#0x32
      000262 A6 28            [ 1]  533 	ld	a, #0x28
      000264 CDr00rA4         [ 4]  534 	call	_rand_minutes_range_to_seconds
      000267 84               [ 1]  535 	pop	a
      000268 20 03            [ 2]  536 	jra	00105$
                                    537 ;	main.c: 160: default: interval_s = 0; break;
      00026A                        538 00104$:
      00026A 5F               [ 1]  539 	clrw	x
      00026B 90 5F            [ 1]  540 	clrw	y
                                    541 ;	main.c: 161: }
      00026D                        542 00105$:
                                    543 ;	main.c: 162: next_on_time_s = uptime_s + interval_s;
      00026D 72 BBu00u06      [ 2]  544 	addw	x, _uptime_s+2
      000271 90 9F            [ 1]  545 	ld	a, yl
      000273 C9u00u05         [ 1]  546 	adc	a, _uptime_s+1
      000276 90 02            [ 1]  547 	rlwa	y
      000278 C9u00u04         [ 1]  548 	adc	a, _uptime_s+0
      00027B 90 95            [ 1]  549 	ld	yh, a
      00027D CFu00u1B         [ 2]  550 	ldw	_next_on_time_s+2, x
      000280 90 CFu00u19      [ 2]  551 	ldw	_next_on_time_s+0, y
                                    552 ;	main.c: 163: }
      000284 81               [ 4]  553 	ret
                                    554 ;	main.c: 166: static void clock_init(void) {
                                    555 ;	-----------------------------------------
                                    556 ;	 function clock_init
                                    557 ;	-----------------------------------------
      000285                        558 _clock_init:
                                    559 ;	main.c: 167: CLK_HSIPrescalerConfig(CLK_PRESCALER_HSIDIV1);
      000285 4F               [ 1]  560 	clr	a
      000286 CDr00r00         [ 4]  561 	call	_CLK_HSIPrescalerConfig
                                    562 ;	main.c: 168: CLK_PeripheralClockConfig(CLK_PERIPHERAL_TIMER4, ENABLE);
      000289 4B 01            [ 1]  563 	push	#0x01
      00028B A6 04            [ 1]  564 	ld	a, #0x04
      00028D CDr00r00         [ 4]  565 	call	_CLK_PeripheralClockConfig
                                    566 ;	main.c: 169: }
      000290 81               [ 4]  567 	ret
                                    568 ;	main.c: 171: static void gpio_init(void) {
                                    569 ;	-----------------------------------------
                                    570 ;	 function gpio_init
                                    571 ;	-----------------------------------------
      000291                        572 _gpio_init:
                                    573 ;	main.c: 173: GPIO_DeInit(GPIOC);
      000291 AE 50 0A         [ 2]  574 	ldw	x, #0x500a
      000294 CDr00r00         [ 4]  575 	call	_GPIO_DeInit
                                    576 ;	main.c: 174: GPIO_DeInit(GPIOD);
      000297 AE 50 0F         [ 2]  577 	ldw	x, #0x500f
      00029A CDr00r00         [ 4]  578 	call	_GPIO_DeInit
                                    579 ;	main.c: 175: GPIO_DeInit(GPIOB);
      00029D AE 50 05         [ 2]  580 	ldw	x, #0x5005
      0002A0 CDr00r00         [ 4]  581 	call	_GPIO_DeInit
                                    582 ;	main.c: 178: GPIO_Init(FAN_PORT, FAN_PIN, GPIO_MODE_OUT_PP_LOW_FAST);
      0002A3 4B E0            [ 1]  583 	push	#0xe0
      0002A5 A6 10            [ 1]  584 	ld	a, #0x10
      0002A7 AE 50 0F         [ 2]  585 	ldw	x, #0x500f
      0002AA CDr00r00         [ 4]  586 	call	_GPIO_Init
                                    587 ;	main.c: 181: GPIO_Init(LED_R_PORT, LED_R_PIN, GPIO_MODE_OUT_PP_HIGH_FAST);
      0002AD 4B F0            [ 1]  588 	push	#0xf0
      0002AF A6 80            [ 1]  589 	ld	a, #0x80
      0002B1 AE 50 0A         [ 2]  590 	ldw	x, #0x500a
      0002B4 CDr00r00         [ 4]  591 	call	_GPIO_Init
                                    592 ;	main.c: 182: GPIO_Init(LED_G_PORT, LED_G_PIN, GPIO_MODE_OUT_PP_HIGH_FAST);
      0002B7 4B F0            [ 1]  593 	push	#0xf0
      0002B9 A6 40            [ 1]  594 	ld	a, #0x40
      0002BB AE 50 0A         [ 2]  595 	ldw	x, #0x500a
      0002BE CDr00r00         [ 4]  596 	call	_GPIO_Init
                                    597 ;	main.c: 183: GPIO_Init(LED_B_PORT, LED_B_PIN, GPIO_MODE_OUT_PP_HIGH_FAST);
      0002C1 4B F0            [ 1]  598 	push	#0xf0
      0002C3 A6 20            [ 1]  599 	ld	a, #0x20
      0002C5 AE 50 0A         [ 2]  600 	ldw	x, #0x500a
      0002C8 CDr00r00         [ 4]  601 	call	_GPIO_Init
                                    602 ;	main.c: 186: GPIO_Init(BTN_PORT, BTN_PIN, GPIO_MODE_IN_PU_NO_IT);
      0002CB 4B 40            [ 1]  603 	push	#0x40
      0002CD A6 10            [ 1]  604 	ld	a, #0x10
      0002CF AE 50 05         [ 2]  605 	ldw	x, #0x5005
      0002D2 CDr00r00         [ 4]  606 	call	_GPIO_Init
                                    607 ;	main.c: 187: }
      0002D5 81               [ 4]  608 	ret
                                    609 ;	main.c: 190: static void tim4_init_1ms(void) {
                                    610 ;	-----------------------------------------
                                    611 ;	 function tim4_init_1ms
                                    612 ;	-----------------------------------------
      0002D6                        613 _tim4_init_1ms:
                                    614 ;	main.c: 192: TIM4_TimeBaseInit(TIM4_PRESCALER_128, 125 - 1);
      0002D6 4B 7C            [ 1]  615 	push	#0x7c
      0002D8 A6 07            [ 1]  616 	ld	a, #0x07
      0002DA CDr00r00         [ 4]  617 	call	_TIM4_TimeBaseInit
                                    618 ;	main.c: 193: TIM4_SetCounter(0);
      0002DD 4F               [ 1]  619 	clr	a
      0002DE CDr00r00         [ 4]  620 	call	_TIM4_SetCounter
                                    621 ;	main.c: 194: TIM4_ClearFlag(TIM4_FLAG_UPDATE);
      0002E1 A6 01            [ 1]  622 	ld	a, #0x01
      0002E3 CDr00r00         [ 4]  623 	call	_TIM4_ClearFlag
                                    624 ;	main.c: 195: TIM4_Cmd(ENABLE);
      0002E6 A6 01            [ 1]  625 	ld	a, #0x01
                                    626 ;	main.c: 196: }
      0002E8 CCr00r00         [ 2]  627 	jp	_TIM4_Cmd
                                    628 ;	main.c: 198: static void wwdg_init(void) {
                                    629 ;	-----------------------------------------
                                    630 ;	 function wwdg_init
                                    631 ;	-----------------------------------------
      0002EB                        632 _wwdg_init:
                                    633 ;	main.c: 199: WWDG_Init(WWDG_START_COUNTER, WWDG_WINDOW);
      0002EB 4B 50            [ 1]  634 	push	#0x50
      0002ED A6 7F            [ 1]  635 	ld	a, #0x7f
      0002EF CDr00r00         [ 4]  636 	call	_WWDG_Init
                                    637 ;	main.c: 200: }
      0002F2 81               [ 4]  638 	ret
                                    639 ;	main.c: 203: static inline void wwdg_service(void) {
                                    640 ;	-----------------------------------------
                                    641 ;	 function wwdg_service
                                    642 ;	-----------------------------------------
      0002F3                        643 _wwdg_service:
                                    644 ;	main.c: 204: uint8_t c = (uint8_t)(WWDG_GetCounter() & 0x7F);
      0002F3 CDr00r00         [ 4]  645 	call	_WWDG_GetCounter
      0002F6 A4 7F            [ 1]  646 	and	a, #0x7f
                                    647 ;	main.c: 205: if ((c < WWDG_WINDOW) && (c >= WWDG_REFRESH_FLOOR)) {
      0002F8 A1 50            [ 1]  648 	cp	a, #0x50
      0002FA 25 01            [ 1]  649 	jrc	00120$
      0002FC 81               [ 4]  650 	ret
      0002FD                        651 00120$:
      0002FD A1 44            [ 1]  652 	cp	a, #0x44
      0002FF 24 01            [ 1]  653 	jrnc	00121$
      000301 81               [ 4]  654 	ret
      000302                        655 00121$:
                                    656 ;	main.c: 206: WWDG_SetCounter(WWDG_START_COUNTER);
      000302 A6 7F            [ 1]  657 	ld	a, #0x7f
                                    658 ;	main.c: 208: }
      000304 CCr00r00         [ 2]  659 	jp	_WWDG_SetCounter
                                    660 ;	main.c: 211: static void enter_mode(mode_t m) {
                                    661 ;	-----------------------------------------
                                    662 ;	 function enter_mode
                                    663 ;	-----------------------------------------
      000307                        664 _enter_mode:
                                    665 ;	main.c: 214: switch (mode) {
      000307 C7u00u13         [ 1]  666 	ld	_mode+0, a
      00030A 27 15            [ 1]  667 	jreq	00101$
      00030C C6u00u13         [ 1]  668 	ld	a, _mode+0
      00030F 4A               [ 1]  669 	dec	a
      000310 27 1E            [ 1]  670 	jreq	00104$
      000312 C6u00u13         [ 1]  671 	ld	a, _mode+0
      000315 A1 02            [ 1]  672 	cp	a, #0x02
      000317 27 17            [ 1]  673 	jreq	00104$
      000319 C6u00u13         [ 1]  674 	ld	a, _mode+0
      00031C A1 03            [ 1]  675 	cp	a, #0x03
      00031E 27 10            [ 1]  676 	jreq	00104$
      000320 81               [ 4]  677 	ret
                                    678 ;	main.c: 215: case MODE_OFF:
      000321                        679 00101$:
                                    680 ;	main.c: 96: static inline void fan_off(void)  { GPIO_WriteLow (FAN_PORT, FAN_PIN);  fan_on = 0; }
      000321 A6 10            [ 1]  681 	ld	a, #0x10
      000323 AE 50 0F         [ 2]  682 	ldw	x, #0x500f
      000326 CDr00r00         [ 4]  683 	call	_GPIO_WriteLow
      000329 72 5Fu00u14      [ 1]  684 	clr	_fan_on+0
                                    685 ;	main.c: 217: led_off_all();
                                    686 ;	main.c: 218: break;
      00032D CCr01r35         [ 2]  687 	jp	_led_off_all
                                    688 ;	main.c: 222: case MODE_HIGH:
      000330                        689 00104$:
                                    690 ;	main.c: 224: led_set_for_mode(mode);
      000330 C6u00u13         [ 1]  691 	ld	a, _mode+0
      000333 CDr01r4D         [ 4]  692 	call	_led_set_for_mode
                                    693 ;	main.c: 96: static inline void fan_off(void)  { GPIO_WriteLow (FAN_PORT, FAN_PIN);  fan_on = 0; }
      000336 A6 10            [ 1]  694 	ld	a, #0x10
      000338 AE 50 0F         [ 2]  695 	ldw	x, #0x500f
      00033B CDr00r00         [ 4]  696 	call	_GPIO_WriteLow
      00033E 72 5Fu00u14      [ 1]  697 	clr	_fan_on+0
                                    698 ;	main.c: 226: schedule_next_interval();
                                    699 ;	main.c: 228: }
                                    700 ;	main.c: 229: }
      000342 CCr02r36         [ 2]  701 	jp	_schedule_next_interval
                                    702 ;	main.c: 232: static void advance_mode(void) {
                                    703 ;	-----------------------------------------
                                    704 ;	 function advance_mode
                                    705 ;	-----------------------------------------
      000345                        706 _advance_mode:
                                    707 ;	main.c: 233: switch (mode) {
      000345 C6u00u13         [ 1]  708 	ld	a, _mode+0
      000348 27 15            [ 1]  709 	jreq	00101$
      00034A C6u00u13         [ 1]  710 	ld	a, _mode+0
      00034D 4A               [ 1]  711 	dec	a
      00034E 27 14            [ 1]  712 	jreq	00102$
      000350 C6u00u13         [ 1]  713 	ld	a, _mode+0
      000353 A1 02            [ 1]  714 	cp	a, #0x02
      000355 27 12            [ 1]  715 	jreq	00103$
      000357 C6u00u13         [ 1]  716 	ld	a, _mode+0
      00035A A1 03            [ 1]  717 	cp	a, #0x03
      00035C 27 10            [ 1]  718 	jreq	00104$
      00035E 81               [ 4]  719 	ret
                                    720 ;	main.c: 234: case MODE_OFF:  enter_mode(MODE_ECO);  break;
      00035F                        721 00101$:
      00035F A6 01            [ 1]  722 	ld	a, #0x01
      000361 CCr03r07         [ 2]  723 	jp	_enter_mode
                                    724 ;	main.c: 235: case MODE_ECO:  enter_mode(MODE_MID);  break;
      000364                        725 00102$:
      000364 A6 02            [ 1]  726 	ld	a, #0x02
      000366 CCr03r07         [ 2]  727 	jp	_enter_mode
                                    728 ;	main.c: 236: case MODE_MID:  enter_mode(MODE_HIGH); break;
      000369                        729 00103$:
      000369 A6 03            [ 1]  730 	ld	a, #0x03
      00036B CCr03r07         [ 2]  731 	jp	_enter_mode
                                    732 ;	main.c: 237: case MODE_HIGH: enter_mode(MODE_OFF);  break;
      00036E                        733 00104$:
      00036E 4F               [ 1]  734 	clr	a
                                    735 ;	main.c: 238: }
                                    736 ;	main.c: 239: }
      00036F CCr03r07         [ 2]  737 	jp	_enter_mode
                                    738 ;	main.c: 242: int main(void) {
                                    739 ;	-----------------------------------------
                                    740 ;	 function main
                                    741 ;	-----------------------------------------
      000372                        742 _main:
      000372 52 04            [ 2]  743 	sub	sp, #4
                                    744 ;	main.c: 243: clock_init();
      000374 CDr02r85         [ 4]  745 	call	_clock_init
                                    746 ;	main.c: 244: gpio_init();
      000377 CDr02r91         [ 4]  747 	call	_gpio_init
                                    748 ;	main.c: 245: tim4_init_1ms();
      00037A CDr02rD6         [ 4]  749 	call	_tim4_init_1ms
                                    750 ;	main.c: 246: wwdg_init();
      00037D CDr02rEB         [ 4]  751 	call	_wwdg_init
                                    752 ;	main.c: 249: enter_mode(MODE_OFF);
      000380 4F               [ 1]  753 	clr	a
      000381 CDr03r07         [ 4]  754 	call	_enter_mode
                                    755 ;	main.c: 252: lfsr ^= (uint16_t)TIM4->CNTR;
      000384 C6 53 46         [ 1]  756 	ld	a, 0x5346
      000387 C8u00u1E         [ 1]  757 	xor	a, _lfsr+1
      00038A 97               [ 1]  758 	ld	xl, a
      00038B 4F               [ 1]  759 	clr	a
      00038C C8u00u1D         [ 1]  760 	xor	a, _lfsr+0
      00038F 95               [ 1]  761 	ld	xh, a
      000390 CFu00u1D         [ 2]  762 	ldw	_lfsr+0, x
                                    763 ;	main.c: 254: uint32_t last_ms = 0;
      000393 5F               [ 1]  764 	clrw	x
      000394 1F 03            [ 2]  765 	ldw	(0x03, sp), x
      000396 1F 01            [ 2]  766 	ldw	(0x01, sp), x
      000398                        767 00137$:
                                    768 ;	main.c: 70: if (TIM4_GetFlagStatus(TIM4_FLAG_UPDATE) != RESET) {
      000398 A6 01            [ 1]  769 	ld	a, #0x01
      00039A CDr00r00         [ 4]  770 	call	_TIM4_GetFlagStatus
      00039D 4D               [ 1]  771 	tnz	a
      00039E 27 49            [ 1]  772 	jreq	00129$
                                    773 ;	main.c: 71: TIM4_ClearFlag(TIM4_FLAG_UPDATE);
      0003A0 A6 01            [ 1]  774 	ld	a, #0x01
      0003A2 CDr00r00         [ 4]  775 	call	_TIM4_ClearFlag
                                    776 ;	main.c: 72: uptime_ms++;
      0003A5 CEu00u02         [ 2]  777 	ldw	x, _uptime_ms+2
      0003A8 90 CEu00u00      [ 2]  778 	ldw	y, _uptime_ms+0
      0003AC 5C               [ 1]  779 	incw	x
      0003AD 26 02            [ 1]  780 	jrne	00247$
      0003AF 90 5C            [ 1]  781 	incw	y
      0003B1                        782 00247$:
      0003B1 CFu00u02         [ 2]  783 	ldw	_uptime_ms+2, x
      0003B4 90 CFu00u00      [ 2]  784 	ldw	_uptime_ms+0, y
                                    785 ;	main.c: 73: if ((uptime_ms % MS_PER_SEC) == 0u) {
      0003B8 4B E8            [ 1]  786 	push	#0xe8
      0003BA 4B 03            [ 1]  787 	push	#0x03
      0003BC 5F               [ 1]  788 	clrw	x
      0003BD 89               [ 2]  789 	pushw	x
      0003BE 3Bu00u03         [ 1]  790 	push	_uptime_ms+3
      0003C1 3Bu00u02         [ 1]  791 	push	_uptime_ms+2
      0003C4 3Bu00u01         [ 1]  792 	push	_uptime_ms+1
      0003C7 3Bu00u00         [ 1]  793 	push	_uptime_ms+0
      0003CA CDr00r00         [ 4]  794 	call	__modulong
      0003CD 5B 08            [ 2]  795 	addw	sp, #8
      0003CF 5D               [ 2]  796 	tnzw	x
      0003D0 26 17            [ 1]  797 	jrne	00129$
      0003D2 90 5D            [ 2]  798 	tnzw	y
      0003D4 26 13            [ 1]  799 	jrne	00129$
                                    800 ;	main.c: 74: uptime_s++;
      0003D6 CEu00u06         [ 2]  801 	ldw	x, _uptime_s+2
      0003D9 90 CEu00u04      [ 2]  802 	ldw	y, _uptime_s+0
      0003DD 5C               [ 1]  803 	incw	x
      0003DE 26 02            [ 1]  804 	jrne	00250$
      0003E0 90 5C            [ 1]  805 	incw	y
      0003E2                        806 00250$:
      0003E2 CFu00u06         [ 2]  807 	ldw	_uptime_s+2, x
      0003E5 90 CFu00u04      [ 2]  808 	ldw	_uptime_s+0, y
                                    809 ;	main.c: 258: tick_1ms_poll();
      0003E9                        810 00129$:
                                    811 ;	main.c: 261: if (uptime_ms != last_ms) {
      0003E9 1E 03            [ 2]  812 	ldw	x, (0x03, sp)
      0003EB C3u00u02         [ 2]  813 	cpw	x, _uptime_ms+2
      0003EE 26 0A            [ 1]  814 	jrne	00252$
      0003F0 1E 01            [ 2]  815 	ldw	x, (0x01, sp)
      0003F2 C3u00u00         [ 2]  816 	cpw	x, _uptime_ms+0
      0003F5 26 03            [ 1]  817 	jrne	00252$
      0003F7 CCr04rD0         [ 2]  818 	jp	00123$
      0003FA                        819 00252$:
                                    820 ;	main.c: 262: last_ms = uptime_ms;
      0003FA CEu00u02         [ 2]  821 	ldw	x, _uptime_ms+2
      0003FD 1F 03            [ 2]  822 	ldw	(0x03, sp), x
      0003FF CEu00u00         [ 2]  823 	ldw	x, _uptime_ms+0
      000402 1F 01            [ 2]  824 	ldw	(0x01, sp), x
                                    825 ;	main.c: 265: button_update_1ms();
      000404 CDr01r87         [ 4]  826 	call	_button_update_1ms
                                    827 ;	main.c: 268: if (btn.long_event) {
      000407 C6u00u12         [ 1]  828 	ld	a, _btn+10
      00040A 27 0A            [ 1]  829 	jreq	00104$
                                    830 ;	main.c: 269: btn.long_event = 0u;
      00040C 35 00u00u12      [ 1]  831 	mov	_btn+10, #0x00
                                    832 ;	main.c: 270: enter_mode(MODE_OFF);                 /* Long press => OFF */
      000410 4F               [ 1]  833 	clr	a
      000411 CDr03r07         [ 4]  834 	call	_enter_mode
      000414 20 0C            [ 2]  835 	jra	00105$
      000416                        836 00104$:
                                    837 ;	main.c: 271: } else if (btn.short_event) {
      000416 C6u00u11         [ 1]  838 	ld	a, _btn+9
      000419 27 07            [ 1]  839 	jreq	00105$
                                    840 ;	main.c: 272: btn.short_event = 0u;
      00041B 35 00u00u11      [ 1]  841 	mov	_btn+9, #0x00
                                    842 ;	main.c: 273: advance_mode();                        /* Short press => next mode, LED updates immediately */
      00041F CDr03r45         [ 4]  843 	call	_advance_mode
      000422                        844 00105$:
                                    845 ;	main.c: 277: if ((uptime_ms % MS_PER_SEC) == 0u) {
      000422 4B E8            [ 1]  846 	push	#0xe8
      000424 4B 03            [ 1]  847 	push	#0x03
      000426 5F               [ 1]  848 	clrw	x
      000427 89               [ 2]  849 	pushw	x
      000428 3Bu00u03         [ 1]  850 	push	_uptime_ms+3
      00042B 3Bu00u02         [ 1]  851 	push	_uptime_ms+2
      00042E 3Bu00u01         [ 1]  852 	push	_uptime_ms+1
      000431 3Bu00u00         [ 1]  853 	push	_uptime_ms+0
      000434 CDr00r00         [ 4]  854 	call	__modulong
      000437 5B 08            [ 2]  855 	addw	sp, #8
      000439 5D               [ 2]  856 	tnzw	x
      00043A 26 04            [ 1]  857 	jrne	00256$
      00043C 90 5D            [ 2]  858 	tnzw	y
      00043E 27 03            [ 1]  859 	jreq	00257$
      000440                        860 00256$:
      000440 CCr04rD0         [ 2]  861 	jp	00123$
      000443                        862 00257$:
                                    863 ;	main.c: 278: if (mode == MODE_ECO || mode == MODE_MID || mode == MODE_HIGH) {
      000443 C6u00u13         [ 1]  864 	ld	a, _mode+0
      000446 4A               [ 1]  865 	dec	a
      000447 27 0E            [ 1]  866 	jreq	00115$
      000449 C6u00u13         [ 1]  867 	ld	a, _mode+0
      00044C A1 02            [ 1]  868 	cp	a, #0x02
      00044E 27 07            [ 1]  869 	jreq	00115$
      000450 C6u00u13         [ 1]  870 	ld	a, _mode+0
      000453 A1 03            [ 1]  871 	cp	a, #0x03
      000455 26 68            [ 1]  872 	jrne	00116$
      000457                        873 00115$:
                                    874 ;	main.c: 279: if (fan_on) {
      000457 C6u00u14         [ 1]  875 	ld	a, _fan_on+0
      00045A 27 33            [ 1]  876 	jreq	00111$
                                    877 ;	main.c: 281: if ((uptime_s - fan_on_started_s) >= FAN_ON_DURATION_S) {
      00045C CEu00u06         [ 2]  878 	ldw	x, _uptime_s+2
      00045F 72 B0u00u17      [ 2]  879 	subw	x, _fan_on_started_s+2
      000463 C6u00u05         [ 1]  880 	ld	a, _uptime_s+1
      000466 C2u00u16         [ 1]  881 	sbc	a, _fan_on_started_s+1
      000469 90 97            [ 1]  882 	ld	yl, a
      00046B C6u00u04         [ 1]  883 	ld	a, _uptime_s+0
      00046E C2u00u15         [ 1]  884 	sbc	a, _fan_on_started_s+0
      000471 88               [ 1]  885 	push	a
      000472 A3 01 2C         [ 2]  886 	cpw	x, #0x012c
      000475 90 9F            [ 1]  887 	ld	a, yl
      000477 A2 00            [ 1]  888 	sbc	a, #0x00
      000479 84               [ 1]  889 	pop	a
      00047A A2 00            [ 1]  890 	sbc	a, #0x00
      00047C 25 52            [ 1]  891 	jrc	00123$
                                    892 ;	main.c: 96: static inline void fan_off(void)  { GPIO_WriteLow (FAN_PORT, FAN_PIN);  fan_on = 0; }
      00047E A6 10            [ 1]  893 	ld	a, #0x10
      000480 AE 50 0F         [ 2]  894 	ldw	x, #0x500f
      000483 CDr00r00         [ 4]  895 	call	_GPIO_WriteLow
      000486 72 5Fu00u14      [ 1]  896 	clr	_fan_on+0
                                    897 ;	main.c: 283: schedule_next_interval();        /* pick new jitter for the next interval */
      00048A CDr02r36         [ 4]  898 	call	_schedule_next_interval
      00048D 20 41            [ 2]  899 	jra	00123$
      00048F                        900 00111$:
                                    901 ;	main.c: 287: if (uptime_s >= next_on_time_s) {
      00048F CEu00u06         [ 2]  902 	ldw	x, _uptime_s+2
      000492 C3u00u1B         [ 2]  903 	cpw	x, _next_on_time_s+2
      000495 C6u00u05         [ 1]  904 	ld	a, _uptime_s+1
      000498 C2u00u1A         [ 1]  905 	sbc	a, _next_on_time_s+1
      00049B C6u00u04         [ 1]  906 	ld	a, _uptime_s+0
      00049E C2u00u19         [ 1]  907 	sbc	a, _next_on_time_s+0
      0004A1 25 2D            [ 1]  908 	jrc	00123$
                                    909 ;	main.c: 97: static inline void fan_on_fn(void){ GPIO_WriteHigh(FAN_PORT, FAN_PIN);  fan_on = 1; fan_on_started_s = uptime_s; }
      0004A3 A6 10            [ 1]  910 	ld	a, #0x10
      0004A5 AE 50 0F         [ 2]  911 	ldw	x, #0x500f
      0004A8 CDr00r00         [ 4]  912 	call	_GPIO_WriteHigh
      0004AB 35 01u00u14      [ 1]  913 	mov	_fan_on+0, #0x01
      0004AF CEu00u06         [ 2]  914 	ldw	x, _uptime_s+2
      0004B2 90 CEu00u04      [ 2]  915 	ldw	y, _uptime_s+0
      0004B6 CFu00u17         [ 2]  916 	ldw	_fan_on_started_s+2, x
      0004B9 90 CFu00u15      [ 2]  917 	ldw	_fan_on_started_s+0, y
                                    918 ;	main.c: 288: fan_on_fn();
      0004BD 20 11            [ 2]  919 	jra	00123$
      0004BF                        920 00116$:
                                    921 ;	main.c: 293: if (fan_on) fan_off();
      0004BF C6u00u14         [ 1]  922 	ld	a, _fan_on+0
      0004C2 27 0C            [ 1]  923 	jreq	00123$
                                    924 ;	main.c: 96: static inline void fan_off(void)  { GPIO_WriteLow (FAN_PORT, FAN_PIN);  fan_on = 0; }
      0004C4 A6 10            [ 1]  925 	ld	a, #0x10
      0004C6 AE 50 0F         [ 2]  926 	ldw	x, #0x500f
      0004C9 CDr00r00         [ 4]  927 	call	_GPIO_WriteLow
      0004CC 72 5Fu00u14      [ 1]  928 	clr	_fan_on+0
                                    929 ;	main.c: 293: if (fan_on) fan_off();
      0004D0                        930 00123$:
                                    931 ;	main.c: 204: uint8_t c = (uint8_t)(WWDG_GetCounter() & 0x7F);
      0004D0 CDr00r00         [ 4]  932 	call	_WWDG_GetCounter
      0004D3 A4 7F            [ 1]  933 	and	a, #0x7f
                                    934 ;	main.c: 205: if ((c < WWDG_WINDOW) && (c >= WWDG_REFRESH_FLOOR)) {
      0004D5 A1 50            [ 1]  935 	cp	a, #0x50
      0004D7 25 03            [ 1]  936 	jrc	00271$
      0004D9 CCr03r98         [ 2]  937 	jp	00137$
      0004DC                        938 00271$:
      0004DC A1 44            [ 1]  939 	cp	a, #0x44
      0004DE 24 03            [ 1]  940 	jrnc	00272$
      0004E0 CCr03r98         [ 2]  941 	jp	00137$
      0004E3                        942 00272$:
                                    943 ;	main.c: 206: WWDG_SetCounter(WWDG_START_COUNTER);
      0004E3 A6 7F            [ 1]  944 	ld	a, #0x7f
      0004E5 CDr00r00         [ 4]  945 	call	_WWDG_SetCounter
                                    946 ;	main.c: 299: wwdg_service();
                                    947 ;	main.c: 301: }
      0004E8 CCr03r98         [ 2]  948 	jp	00137$
                                    949 	.area CODE
                                    950 	.area CONST
                                    951 	.area INITIALIZER
      000000                        952 __xinit__uptime_ms:
      000000 00 00 00 00            953 	.byte #0x00, #0x00, #0x00, #0x00	; 0
      000004                        954 __xinit__uptime_s:
      000004 00 00 00 00            955 	.byte #0x00, #0x00, #0x00, #0x00	; 0
      000008                        956 __xinit__btn:
      000008 01                     957 	.db #0x01	; 1
      000009 01                     958 	.db #0x01	; 1
      00000A 00 00                  959 	.dw #0x0000
      00000C 00                     960 	.db #0x00	; 0
      00000D 00 00 00 00            961 	.byte #0x00, #0x00, #0x00, #0x00	; 0
      000011 00                     962 	.db #0x00	; 0
      000012 00                     963 	.db #0x00	; 0
      000013                        964 __xinit__mode:
      000013 00                     965 	.db #0x00	; 0
      000014                        966 __xinit__fan_on:
      000014 00                     967 	.db #0x00	; 0
      000015                        968 __xinit__fan_on_started_s:
      000015 00 00 00 00            969 	.byte #0x00, #0x00, #0x00, #0x00	; 0
      000019                        970 __xinit__next_on_time_s:
      000019 00 00 00 00            971 	.byte #0x00, #0x00, #0x00, #0x00	; 0
      00001D                        972 __xinit__lfsr:
      00001D AC E1                  973 	.dw #0xace1
                                    974 	.area CABS (ABS)
